diff --git a/INSTALL b/INSTALL
index 339124e..8cff865 100644
--- a/INSTALL
+++ b/INSTALL
@@ -9,10 +9,10 @@ To install System Storage Manager into your system simply run:
    python setup.py install
 
 as root in the System Storage Manager directory. Make sure that your
-system configuration meet the *requirements* in order for ssm to work
+system configuration meets the *requirements* in order for ssm to work
 correctly.
 
-Note that you can run **ssm** even without installation from using the
+Note that you can run **ssm** even without installation by using the
 local sources with:
 
    bin/ssm.local
@@ -22,12 +22,12 @@ Requirements
 ************
 
 Python 2.6 or higher is required to run this tool. System Storage
-Manager can only be run as root since most of the commands requires
+Manager can only be run as root since most of the commands require
 root privileges.
 
-There are other requirements listed bellow, but note that you do not
-necessarily need all dependencies for all backends, however if some of
-the tools required by the backend is missing, the backend would not
+There are other requirements listed below, but note that you do not
+necessarily need all dependencies for all backends. However if some of
+the tools required by a backend are missing, that backend will not
 work.
 
 
diff --git a/README b/README
index 71b09e8..31eb42f 100644
--- a/README
+++ b/README
@@ -8,8 +8,8 @@ A single tool to manage your storage.
 Description
 ***********
 
-System Storage Manager provides easy to use command line interface to
-manage your storage using various technologies like lvm, btrfs,
+System Storage Manager provides an easy to use command line interface
+to manage your storage using various technologies like lvm, btrfs,
 encrypted volumes and more.
 
 In more sophisticated enterprise storage environments, management with
@@ -51,59 +51,76 @@ Commands
 Introduction
 ************
 
-System Storage Manager have several commands you can specify on the
-command line as a first argument to the ssm. They all have specific
-use and its own arguments, but global ssm arguments are propagated to
-all commands.
+System Storage Manager has several commands that you can specify on
+the command line as a first argument to ssm. They all have a specific
+use and their own arguments, but global ssm arguments are propagated
+to all commands.
 
 
 Create command
 **************
 
-This command creates a new volume with defined parameters. If
-**device** is provided it will be used to create a volume, hence it
-will be added into the **pool** prior the volume creation (See *Add
-command section*). More devices can be used to create a volume.
-
-If the **device** is already used in the different pool, then **ssm**
-will ask you whether you want to remove it from the original pool. If
-you decline, or the removal fails, then the **volume** creation fails
-if the *SIZE* was not provided. On the other hand, if the *SIZE* is
-provided and some devices can not be added to the **pool** the volume
-creation might succeed if there is enough space in the **pool**.
-
-*POOL* name can be specified as well. If the pool exists new volume
-will be created from that pool (optionally adding **device** into the
-pool). However if the *POOL* does not exist **ssm** will attempt to
-create a new pool with provided **device** and then create a new
-volume from this pool. If **--backend** argument is omitted, the
-default **ssm** backend will be used. Default backend is *lvm*.
-
-**ssm** also supports creating RAID configuration, however some back-
-ends might not support all the levels, or it might not support RAID at
-all. In this case, volume creation will fail.
-
-If **mount** point is provided **ssm** will attempt to mount the
+This command creates a new volume with defined parameters. If a
+**device** is provided it will be used to create the volume, hence it
+will be added into the **pool** prior to volume creation (See *Add
+command section*). More than one device can be used to create a
+volume.
+
+If the **device** is already being used in a different pool, then
+**ssm** will ask you whether you want to remove it from the original
+pool. If you decline, or the removal fails, then the **volume**
+creation fails if the *SIZE* was not provided. On the other hand, if
+the *SIZE* is provided and some devices can not be added to the
+**pool**, the volume creation might still succeed if there is enough
+space in the **pool**.
+
+In addition to specifying size of the volume directly, percentage can
+be specified as well. Specify **--size 70%** to indicate the volume
+size to be 70% of total pool size. Additionally, percentage of the
+used, or free pool space can be specified as well using keywords FREE,
+or USED respectively.
+
+The *POOL* name can be specified as well. If the pool exists, a new
+volume will be created from that pool (optionally adding **device**
+into the pool). However if the *POOL* does not exist, then **ssm**
+will attempt to create a new pool with the provided **device**, and
+then create a new volume from this pool. If the **--backend** argument
+is omitted, the default **ssm** backend will be used. The default
+backend is *lvm*.
+
+**ssm** also supports creating a RAID configuration, however some
+back-ends might not support all RAID levels, or may not even support
+RAID at all. In this case, volume creation will fail.
+
+If a **mount** point is provided, **ssm** will attempt to mount the
 volume after it is created. However it will fail if mountable file
 system is not present on the volume.
 
+If the backend allows it (currently only supported with **lvm**
+backend), **ssm** can be used to create **thinly provisioned volumes**
+by specifying **--virtual-size** option. This will automatically
+create a **thin pool** of a given size provided with **--size** option
+and **thin volume** of a given size provided with **--virtual-size**
+option and name provided with **--name** option. Virtual size can be
+much bigger than available space in the **pool**.
+
 
 List command
 ************
 
-List informations about all detected devices, pools, volumes and
-snapshots found in the system. **list** command can be used either
-alone to list all the information, or you can request specific section
-only.
+Lists information about all detected devices, pools, volumes and
+snapshots found on the system. The **list** command can be used either
+alone to list all of the information, or you can request specific
+sections only.
 
-Following sections can be specified:
+The following sections can be specified:
 
 {volumes | vol}
    List information about all **volumes** found in the system.
 
 {devices | dev}
-   List information about all **devices** found in the system. Some
-   devices are intentionally hidden, like for example cdrom, or DM/MD
+   List information about all **devices** found on the system. Some
+   devices are intentionally hidden, like for example cdrom or DM/MD
    devices since those are actually listed as volumes.
 
 {pools | pool}
@@ -115,52 +132,60 @@ Following sections can be specified:
 
 {snapshots | snap}
    List information about all **snapshots** found in the system. Note
-   that some back-ends does not support snapshotting and some can not
-   distinguish between snapshot and regular volume. in this case
-   **ssm** will try to recognize volume name in order to identify
+   that some back-ends do not support snapshotting and some cannot
+   distinguish snapshot from regular volumes. In this case, **ssm**
+   will try to recognize the volume name in order to identify a
    **snapshot**, but if the **ssm** regular expression does not match
-   the snapshot pattern, this snapshot will not be recognized.
+   the snapshot pattern, the problematic snapshot will not be
+   recognized.
 
 
 Remove command
 **************
 
-This command removes **item** from the system. Multiple items can be
-specified. If the **item** can not be removed for some reason, it will
-be skipped.
+This command removes an **item** from the system. Multiple items can
+be specified.  If the **item** cannot be removed for some reason, it
+will be skipped.
 
-**item** can represent:
+An **item** can be any of the following:
 
 device
-   Remove **device** from the pool. Note that this can not be done in
-   some cases where the device is used by pool. You can use **-f**
-   argument to *force* removal. If the device does not belong to any
-   pool, it will be skipped.
+   Remove a **device** from the pool. Note that this cannot be done in
+   some cases where the device is being used by the pool. You can use
+   the **-f** argument to *force* removal. If the device does not
+   belong to any pool, it will be skipped.
 
 pool
-   Remove the **pool** from the system. This will also remove all
+   Remove a **pool** from the system. This will also remove all
    volumes created from that pool.
 
 volume
-   Remove the **volume** from the system. Note that this will fail if
-   the **volume** is mounted and it can not be *forced* with **-f**.
+   Remove a **volume** from the system. Note that this will fail if
+   the **volume** is mounted and cannot be *forced* with **-f**.
 
 
 Resize command
 **************
 
 Change size of the **volume** and file system. If there is no file
-system only the **volume** itself will be resized. You can specify
+system, only the **volume** itself will be resized. You can specify a
 **device** to add into the **volume** pool prior the resize. Note that
-**device** will only be added into the pool if the **volume** size is
-going to grow.
+the **device** will only be added into the pool if the **volume** size
+is going to grow.
+
+If the **device** is already used in a different pool, then **ssm**
+will ask you whether or not you want to remove it from the original
+pool.
 
-If the **device** is already used in the different pool, then **ssm**
-will ask you whether you want to remove it from the original pool.
+In some cases, the file system has to be mounted in order to resize.
+This will be handled by **ssm** automatically by mounting the
+**volume** temporarily.
 
-In some cases file system has to be mounted in order to resize. This
-will be handled by **ssm** automatically by mounting the **volume**
-temporarily.
+In addition to specifying new size of the volume directly, percentage
+can be specified as well. Specify **--size 70%** to resize the volume
+to 70% of it's original size. Additionally, percentage of the used, or
+free pool space can be specified as well using keywords FREE, or USED
+respectively.
 
 Note that resizing btrfs subvolume is not supported, only the whole
 file system can be resized.
@@ -173,20 +198,26 @@ Check the file system consistency on the **volume**. You can specify
 multiple volumes to check. If there is no file system on the
 **volume**, this **volume** will be skipped.
 
-In some cases file system has to be mounted in order to check the file
-system This will be handled by **ssm** automatically by mounting the
-**volume** temporarily.
+In some cases the file system has to be mounted in order to check the
+file system.  This will be handled by **ssm** automatically by
+mounting the **volume** temporarily.
 
 
 Snapshot command
 ****************
 
-Take a snapshot of existing **volume**. This operation will fail if
-back-end which the **volume** belongs to does not support
-snapshotting. Note that you can not specify both *NAME* and *DESC*
+Take a snapshot of an existing **volume**. This operation will fail if
+the back-end to which the **volume** belongs to does not support
+snapshotting. Note that you cannot specify both *NAME* and *DEST*
 since those options are mutually exclusive.
 
-In some cases file system has to be mounted in order to take a
+In addition to specifying new size of the volume directly, percentage
+can be specified as well. Specify **--size 70%** to indicate the new
+snapshot size to be 70% of the origin volume size. Additionally,
+percentage of the used, or free pool space can be specified as well
+using keywords FREE, or USED respectively.
+
+In some cases the file system has to be mounted in order to take a
 snapshot of the **volume**. This will be handled by **ssm**
 automatically by mounting the **volume** temporarily.
 
@@ -194,14 +225,14 @@ automatically by mounting the **volume** temporarily.
 Add command
 ***********
 
-This command adds **device** into the pool. The **device** will not be
-added if it's already part of different pool by default, but user will
-be asked whether to remove the device from it's pool. When multiple
-devices are provided, all of them are added into the pool. If one of
-the devices can not be added into the pool for any reason, add command
-will fail. If no pool is specified, default pool will be chosen. In
-the case of non existing pool, it will be created using provided
-devices.
+This command adds a **device** into the pool. By default, the
+**device** will not be added if it's already a part of a different
+pool, but the user will be asked whether or not to remove the device
+from its pool. When multiple devices are provided, all of them are
+added into the pool. If one of the devices cannot be added into the
+pool for any reason, the add command will fail. If no pool is
+specified, the default pool will be chosen. In the case of a non
+existing pool, it will be created using the provided devices.
 
 
 Backends
@@ -211,18 +242,19 @@ Backends
 Introduction
 ************
 
-Ssm aims to create unified user interface for various technologies
+Ssm aims to create a unified user interface for various technologies
 like Device Mapper (dm), Btrfs file system, Multiple Devices (md) and
 possibly more. In order to do so we have a core abstraction layer in
 "ssmlib/main.py". This abstraction layer should ideally know nothing
 about the underlying technology, but rather comply with **device**,
-**pool** and **volume** abstraction.
+**pool** and **volume** abstractions.
 
 Various backends can be registered in "ssmlib/main.py" in order to
-handle specific storage technology implementing methods like *create*,
-*snapshot*, or *remove* volumes and pools. The core will then call
-these methods to manage the storage without needing to know what lies
-underneath it. There are already several backends registered in ssm.
+handle specific storage technology, implementing methods like
+*create*, *snapshot*, or *remove* volumes and pools. The core will
+then call these methods to manage the storage without needing to know
+what lies underneath it. There are already several backends registered
+in ssm.
 
 
 Btrfs backend
@@ -237,64 +269,66 @@ Pools, volumes and snapshots can be created with btrfs backend and
 here is what it means from the btrfs point of view:
 
 pool
-   Pool is actually a btrfs file system itself, because it can be
-   extended by adding more devices, or shrink by removing devices from
+   A pool is actually a btrfs file system itself, because it can be
+   extended by adding more devices, or shrunk by removing devices from
    it. Subvolumes and snapshots can also be created. When the new
-   btrfs pool should be created **ssm** simply creates a btrfs file
+   btrfs pool should be created, **ssm** simply creates a btrfs file
    system, which means that every new btrfs pool has one volume of the
    same name as the pool itself which can not be removed without
-   removing the entire pool. Default btrfs pool name is
+   removing the entire pool. The default btrfs pool name is
    **btrfs_pool**.
 
-   When creating new btrfs pool, the name of the pool is used as the
-   file system label. If there is already existing btrfs file system
-   in the system without a label, btrfs pool name will be generated
-   for internal use in the following format "btrfs_{device base
-   name}".
+   When creating a new btrfs pool, the name of the pool is used as the
+   file system label. If there is an already existing btrfs file
+   system in the system without a label, a btrfs pool name will be
+   generated for internal use in the following format "btrfs_{device
+   base name}".
 
-   Btrfs pool is created when **create** or **add** command is used
-   with devices specified and non existing pool name.
+   A btrfs pool is created when the **create** or **add** command is
+   used with specified devices and non existing pool name.
 
 volume
-   Volume in btrfs back-end is actually just btrfs subvolume with the
-   exception of the first volume created on btrfs pool creation, which
-   is the file system itself. Subvolumes can only be created on btrfs
-   file system when it is mounted, but user does not have to worry
-   about that since **ssm** will automatically mount the file system
-   temporarily in order to create a new subvolume.
-
-   Volume name is used as subvolume path in the btrfs file system and
-   every object in this path must exists in order to create a volume.
-   Volume name for internal tracking and for representing to the user
-   is generated in the format "{pool_name}:{volume name}", but volumes
-   can be also referenced with its mount point.
-
-   Btrfs volumes are only shown in the *list* output, when the file
-   system is mounted, with the exception of the main btrfs volume -
-   the file system itself.
-
-   Also note that btrfs volumes and subvolumes can not be resized.
-   This is mainly limitation of the btrfs tools which currently does
-   not work reliably.
-
-   New btrfs volume can be created with **create** command.
+   A volume in the btrfs back-end is actually just btrfs subvolume
+   with the exception of the first volume created on btrfs pool
+   creation, which is the file system itself. Subvolumes can only be
+   created on the btrfs file system when it is mounted, but the user
+   does not have to worry about that since **ssm** will automatically
+   mount the file system temporarily in order to create a new
+   subvolume.
+
+   The volume name is used as subvolume path in the btrfs file system
+   and every object in this path must exist in order to create a
+   volume. The volume name for internal tracking and that is visible
+   to the user is generated in the format "{pool_name}:{volume name}",
+   but volumes can be also referenced by its mount point.
+
+   The btrfs volumes are only shown in the *list* output, when the
+   file system is mounted, with the exception of the main btrfs volume
+   - the file system itself.
+
+   Also note that btrfs volumes and subvolumes cannot be resized. This
+   is mainly limitation of the btrfs tools which currently do not work
+   reliably.
+
+   A new btrfs volume can be created with the **create** command.
 
 snapshot
-   Btrfs file system support subvolume snapshotting, so you can take a
-   snapshot of any btrfs volume in the system with **ssm**. However
-   btrfs does not distinguish between subvolumes and snapshots,
-   because snapshot actually is just a subvolume with some block
-   shared with different subvolume. It means, that **ssm** is not able
-   to recognize btrfs snapshot directly, but instead it is trying to
-   recognize special name format of the btrfs volume. However, if the
-   *NAME* is specified when creating snapshot which does not match the
+   The btrfs file system supports subvolume snapshotting, so you can
+   take a snapshot of any btrfs volume in the system with **ssm**.
+   However btrfs does not distinguish between subvolumes and
+   snapshots, because a snapshot is actually just a subvolume with
+   some blocks shared with a different subvolume. This means, that
+   **ssm** is not able to directly recognize a btrfs snapshot.
+   Instead, **ssm** will try to recognize a special name format of the
+   btrfs volume that denotes it is a snapshot. However, if the *NAME*
+   is specified when creating snapshot which does not match the
    special pattern, snapshot will not be recognized by the **ssm** and
    it will be listed as regular btrfs volume.
 
-   New btrfs snapshot can be created with **snapshot** command.
+   A new btrfs snapshot can be created with the **snapshot** command.
 
 device
-   Btrfs does not require any special device to be created on.
+   Btrfs does not require a special device to be created on.
 
 
 Lvm backend
@@ -304,66 +338,71 @@ Pools, volumes and snapshots can be created with lvm, which pretty
 much match the lvm abstraction.
 
 pool
-   Lvm pool is just *volume group* in lvm language. It means that it
-   is grouping devices and new logical volumes can be created out of
-   the lvm pool. Default lvm pool name is **lvm_pool**.
+   An lvm pool is just a *volume group* in lvm language. It means that
+   it is grouping devices and new logical volumes can be created out
+   of the lvm pool. The default lvm pool name is **lvm_pool**.
 
-   Lvm pool is created when **create** or **add** command is used with
-   devices specified and non existing pool name.
+   An lvm pool is created when the **create** or **add** commands are
+   used with specified devices and a non existing pool name.
+
+   Alternatively a **thin pool** can be created as a result of using
+   **--virtual-size** option to create **thin volume**.
 
 volume
-   Lvm volume is just *logical volume* in lvm language. Lvm volume can
-   be created wit **create** command.
+   An lvm volume is just a *logical volume* in lvm language. An lvm
+   volume can be created with the **create** command.
 
 snapshot
    Lvm volumes can be snapshotted as well. When a snapshot is created
-   from the lvm volume, new *snapshot* volume is created, which can be
-   handled as any other lvm volume. Unlike *btrfs* lvm is able to
+   from the lvm volume, a new *snapshot* volume is created, which can
+   be handled as any other lvm volume. Unlike *btrfs* lvm is able to
    distinguish snapshot from regular volume, so there is no need for a
    snapshot name to match special pattern.
 
 device
-   Lvm requires *physical device* to be created on the device, but
+   Lvm requires a *physical device* to be created on the device, but
    with **ssm** this is transparent for the user.
 
 
 Crypt backend
 *************
 
-Crypt backend in **ssm** uses cryptsetup and dm-crypt target to manage
-encrypted volumes. Crypt backend can be used as a regular backend for
-creating encrypted volumes on top of regular block devices, or even
-other volumes (lvm or md volumes for example). Or it can be used to
-create encrypted lvm volumes right away in a single step.
+The crypt backend in **ssm** uses cryptsetup and dm-crypt target to
+manage encrypted volumes. The crypt backend can be used as a regular
+backend for creating encrypted volumes on top of regular block
+devices, or even other volumes (lvm or md volumes for example). Or it
+can be used to create encrypted lvm volumes right away in a single
+step.
 
 Only volumes can be created with crypt backend. This backend does not
 support pooling and does not require special devices.
 
 pool
-   Crypt backend does not support pooling it is not possible to create
-   crypt pool or add a device into a pool.
+   The crypt backend does not support pooling, and it is not possible
+   to create crypt pool or add a device into a pool.
 
 volume
-   Volume in crypt backend is the volume created by dm-crypt which
-   represent the data on the original encrypted device in unencrypted
-   form. Crypt backend does not support pooling, so only one device
-   can be used to create crypt volume. It also does not support raid
-   or any device concatenation.
-
-   Currently two modes, or extensions are supported luks and plain.
-   Luks is used by default.For more information about the extensions
+   A volume in the crypt backend is the volume created by dm-crypt
+   which represents the data on the original encrypted device in
+   unencrypted form. The crypt backend does not support pooling, so
+   only one device can be used to create crypt volume. It also does
+   not support raid or any device concatenation.
+
+   Currently two modes, or extensions are supported: luks and plain.
+   Luks is used by default. For more information about the extensions,
    please see **cryptsetup** manual page.
 
 snapshot
-   Crypt backend does not support snapshotting, however if the
-   encrypted volume is created on top of the lvm volume, the lvm
-   volume itself can be snapshotted. The snapshot can be then opened
-   by using **cryptsetup**. It is possible that this might change in
-   the future so that **ssm** will be able to activate the volume
-   directly without the extra step.
+   The crypt backend does not support snapshotting, however if the
+   encrypted volume is created on top of an lvm volume, the lvm volume
+   itself can be snapshotted. The snapshot can be then opened by using
+   **cryptsetup**. It is possible that this might change in the future
+   so that **ssm** will be able to activate the volume directly
+   without the extra step.
 
 device
-   Crypt backend does not require any special device to be created on.
+   The crypt backend does not require a special device to be created
+   on.
 
 
 Environment variables
@@ -371,22 +410,22 @@ Environment variables
 
 SSM_DEFAULT_BACKEND
    Specify which backend will be used by default. This can be
-   overridden by specifying **-b** or **--backend** argument.
-   Currently only *lvm* and *btrfs* is supported.
+   overridden by specifying the **-b** or **--backend** argument.
+   Currently only *lvm* and *btrfs* are supported.
 
 SSM_LVM_DEFAULT_POOL
-   Name of the default lvm pool to be used if **-p** or **--pool**
+   Name of the default lvm pool to be used if the **-p** or **--pool**
    argument is omitted.
 
 SSM_BTRFS_DEFAULT_POOL
-   Name of the default btrfs pool to be used if **-p** or **--pool**
-   argument is omitted.
+   Name of the default btrfs pool to be used if the **-p** or
+   **--pool** argument is omitted.
 
 SSM_PREFIX_FILTER
-   When this is set **ssm** will filter out all devices, volumes and
-   pools which name does not start with this prefix. It is used mainly
-   in **ssm** test suite to make sure that we do not scramble local
-   system configuration.
+   When this is set, **ssm** will filter out all devices, volumes and
+   pools whose name does not start with this prefix. It is used mainly
+   in the **ssm** test suite to make sure that we do not scramble the
+   local system configuration.
 
 
 Quick examples
@@ -418,8 +457,9 @@ List system storage:
    /dev/sda5               49.44 GB  ext4  49.44 GB  29.77 GB  part   /mnt/test
    ------------------------------------------------------------------------------
 
-Creating a volume of defined size with the defined file system. The
-default back-end is set to lvm and lvm default pool name is lvm_pool:
+Create a volume of the defined size with the defined file system. The
+default back-end is set to lvm and the lvm default pool name (volume
+group) is lvm_pool:
 
    # ssm create --fs ext4 -s 15G /dev/loop0 /dev/loop1
 
@@ -428,17 +468,18 @@ volume to 10GB:
 
    # ssm resize -s-5G /dev/lvm_pool/lvol001
 
-Resize the volume to 100G, but it would require to add more devices
-into the pool:
+Resize the volume to 100G, but it may require adding more devices into
+the pool:
 
-   # ssm resize -s 25G /dev/lvm_pool/lvol001 /dev/loop2
+   # ssm resize -s 100G /dev/lvm_pool/lvol001 /dev/loop2
 
-Now we can try to create new lvm volume named 'myvolume' from the
-remaining pool space with xfs file system and mount it to /mnt/test1:
+Now we can try to create a new lvm volume named 'myvolume' from the
+remaining pool space with the xfs file system and mount it to
+/mnt/test1:
 
    # ssm create --fs xfs --name myvolume /mnt/test1
 
-List all volumes with file system:
+List all volumes with file systems:
 
    # ssm list filesystems
    -----------------------------------------------------------------------------------------------
@@ -451,19 +492,19 @@ List all volumes with file system:
    /dev/sda5                              49.44 GB  ext4   49.44 GB  29.77 GB  part    /mnt/test
    -----------------------------------------------------------------------------------------------
 
-You can then easily remove the old volume by:
+You can then easily remove the old volume with:
 
    # ssm remove /dev/lvm_pool/lvol001
 
-Now lest try to create btrfs volume. Btrfs is separate backend, not
-just a file system. That is because btrfs itself have integrated
-volume manager. Defaul btrfs pool name is btrfs_pool.:
+Now let's try to create a btrfs volume. Btrfs is a separate backend,
+not just a file system. That is because btrfs itself has an integrated
+volume manager. The default btrfs pool name is btrfs_pool.:
 
    # ssm -b btrfs create /dev/loop3 /dev/loop4
 
-Now create we btrfs subvolumes. Note that btrfs file system has to be
-mounted in order to create subvolumes. However ssm will handle it for
-you.:
+Now we create btrfs subvolumes. Note that the btrfs file system has to
+be mounted in order to create subvolumes. However ssm will handle this
+for you.:
 
    # ssm create -p btrfs_pool
    # ssm create -n new_subvolume -p btrfs_pool
@@ -502,10 +543,10 @@ you.:
    /dev/sda5                              49.44 GB  ext4   49.44 GB  29.77 GB  part    /mnt/test
    -----------------------------------------------------------------------------------------------
 
-Now let's free up some of the loop devices so we cat try to add them
-into then btrfs_pool. So we'll simply remove lvm mvolume and resize
-lvol001 so we can remove /dev/loop2. Note that myvolume is mounted so
-we have to unmount it first.:
+Now let's free up some of the loop devices so that we can try to add
+them into the btrfs_pool. So we'll simply remove lvm myvolume and
+resize lvol001 so we can remove /dev/loop2. Note that myvolume is
+mounted so we have to unmount it first.:
 
    # umount /mnt/test1
    # ssm remove /dev/lvm_pool/myvolume
@@ -516,8 +557,8 @@ Add device to the btrfs file system:
 
    # ssm add /dev/loop2 -p btrfs_pool
 
-Set' see what happend. Note that to actually see btrfs subvolumes you
-have to mount the file system first:
+Now let's see what happened. Note that to actually see btrfs
+subvolumes you have to mount the file system first:
 
    # mount -L btrfs_pool /mnt/test1/
    # ssm list volumes
@@ -533,9 +574,9 @@ have to mount the file system first:
    /dev/sda5                                     49.44 GB  ext4   49.44 GB  29.77 GB  part    /mnt/test
    ------------------------------------------------------------------------------------------------------------------------
 
-Remove the whole lvm pool and one of the btrfs subvolume, and one
-unused device from the btrfs pool btrfs_loop3. Note that with btrfs,
-pool have the same name as the volume:
+Remove the whole lvm pool, one of the btrfs subvolumes, and one unused
+device from the btrfs pool btrfs_loop3. Note that with btrfs, pools
+have the same name as their volumes:
 
    # ssm remove lvm_pool /dev/loop2 /mnt/test1/new_subvolume/
 
@@ -546,14 +587,14 @@ Snapshots can also be done with ssm:
 
 With lvm, you can also create snapshots:
 
-   root# ssm create -s 10G /dev/loop[01]
+   # ssm create -s 10G /dev/loop[01]
    # ssm snapshot /dev/lvm_pool/lvol001
 
 Now list all snapshots. Note that btrfs snapshots are actually just
 subvolumes with some blocks shared with the original subvolume, so
-there currently no way to distinguish between those. ssm is using a
-little trick to search for name patters to recognize snapshots, so if
-you specify your own name for the snapshot ssm will not recognize it
+there is currently no way to distinguish between those. ssm is using a
+little trick to search for name patterns to recognize snapshots, so if
+you specify your own name for the snapshot, ssm will not recognize it
 as snapshot, but rather as regular volume (subvolume). This problem
 does not exist with lvm.:
 
@@ -574,10 +615,10 @@ To install System Storage Manager into your system simply run:
    python setup.py install
 
 as root in the System Storage Manager directory. Make sure that your
-system configuration meet the *requirements* in order for ssm to work
+system configuration meets the *requirements* in order for ssm to work
 correctly.
 
-Note that you can run **ssm** even without installation from using the
+Note that you can run **ssm** even without installation by using the
 local sources with:
 
    bin/ssm.local
@@ -587,12 +628,12 @@ Requirements
 ************
 
 Python 2.6 or higher is required to run this tool. System Storage
-Manager can only be run as root since most of the commands requires
+Manager can only be run as root since most of the commands require
 root privileges.
 
-There are other requirements listed bellow, but note that you do not
-necessarily need all dependencies for all backends, however if some of
-the tools required by the backend is missing, the backend would not
+There are other requirements listed below, but note that you do not
+necessarily need all dependencies for all backends. However if some of
+the tools required by a backend are missing, that backend will not
 work.
 
 
@@ -665,7 +706,7 @@ Crypt backend
 For developers
 **************
 
-We are accepting patches! If you're interested contributing to the
+We are accepting patches! If you're interested in contributing to the
 System Storage Manager code, just checkout the git repository located
 on SourceForge. Please, base all of your work on the "devel" branch
 since it is more up-to-date and it will save us some work when merging
@@ -680,9 +721,9 @@ are appreciated. See *Mailing list section* section.
 Tests
 =====
 
-System Storage Manager contains regression testing suite to make sure
-that we do not break thing that should already work. And we recommend
-every developer to run tests before sending patches:
+System Storage Manager contains a regression testing suite to make
+sure that we do not break things that should already work. We
+recommend that every developer run these tests before sending patches:
 
    python test.py
 
@@ -707,26 +748,26 @@ Tests in System Storage Manager are divided into four levels.
 
 4. And finally there are real bash tests located in "tests/bashtests".
    Bash tests are divided into files. Each file tests one command for
-   one backend and it containing series of test cases followed by
-   checks whether the command created the expected result. In order to
-   test real system commands we have to create system device to test
-   on and not touch any of the existing system configuration.
+   one backend and it contains a series of test cases followed by
+   checks as to whether the command created the expected result. In
+   order to test real system commands we have to create a system
+   device to test on and not touch the existing system configuration.
 
    Before each test a number of devices are created using *dmsetup* in
    the test directory. These devices will be used in test cases
-   instead of real devices. Real operation are performed in those
-   devices as it would on the real system devices. It implies that
-   this phase requires root privileges and it would not be run
-   otherwise. In order to make sure that **ssm** does not touch any
-   existing system configuration, each device, poor and volume name is
-   include special prefix and SSM_PREFIX_FILTER environment variable
-   is set to make **ssm** to exclude all items which does not match
-   this filter.
-
-   Even though we tried hard to make sure that the bash tests does not
-   change any of your system configuration the recommendation is
-   **not** to run tests as with root privileges on your work or
-   production system, but rather run it on your testing machine.
+   instead of real devices.  Real operations are performed in those
+   devices as they would be on the real system devices. This phase
+   requires root privileges and it will not be run otherwise. In order
+   to make sure that **ssm** does not touch any existing system
+   configuration, each device, pool and volume name includes a special
+   prefix, and the SSM_PREFIX_FILTER environment variable is set to
+   make **ssm** to exclude all items which does not match this special
+   prefix.
+
+   Even though we tried hard to make sure that the bash tests do not
+   change your system configuration, we recommend you **not** to run
+   tests with root privileges on your work or production system, but
+   rather to run them on your testing machine.
 
 If you change or create new functionality, please make sure that it is
 covered by the System Storage Manager regression test suite to make
@@ -740,20 +781,21 @@ Important: Please, make sure to run full tests before you send a patch to the
 Documentation
 =============
 
-System Storage Manager documentation is stored in "doc/" directory.
-The documentation is build using **sphinx** software which help us not
-to duplicate texts for different type of documentation (man page, html
-pages, readme). If you are going to modify documentation, please make
-sure not to modify manual page, html pages or README directly, but
-rather modify "doc/*.rst" and "doc/src/*.rst" files accordingly so the
-change is propagated to all documents.
+System Storage Manager documentation is stored in the "doc/"
+directory. The documentation is built using **sphinx** software which
+helps us not to duplicate text for different types of documentation
+(man page, html pages, readme). If you are going to modify
+documentation, please make sure not to modify manual page, html pages
+or README directly, but rather modify the "doc/*.rst" and
+"doc/src/*.rst" files accordingly so that the change is propagated to
+all documents.
 
 Moreover, parts of the documentation such as *synopsis* or ssm command
-*options* are parsed directly from the ssm help output. It means that
-when you're going to add or change argument into **ssm** the only
-thing you have to do is to add or change it in the "ssmlib/main.py"
-source code and then run "make dist" in the "doc/" directory and all
-the documents should be updated automatically.
+*options* are parsed directly from the ssm help output. This means
+that when you're going to add or change arguments into **ssm** the
+only thing you have to do is to add or change it in the
+"ssmlib/main.py" source code and then run "make dist" in the "doc/"
+directory and all the documents should be updated automatically.
 
 Important: Please make sure you update the documentation when you add or change
   **ssm** functionality if the format of the change requires it. Then
@@ -765,34 +807,34 @@ Mailing list
 ============
 
 System Storage Manager developers communicate via the mailing list.
-Address of our mailing list is storagemanager-
+The address of our mailing list is storagemanager-
 devel@lists.sourceforge.net and you can subscribe on the SourceForge
 project page https://lists.sourceforge.net/lists/listinfo
 /storagemanager-devel. Mailing list archives can be found here
 http://sourceforge.net/mailarchive/forum.php?forum_name
 =storagemanager-devel.
 
-This is also the list where to send patches and where the review
-process is happening. We do not have separate *user* mailing list, so
-feel free to drop your questions there as well.
+This is also the list where patches are sent and where the review
+process is happening. We do not have a separate *user* mailing list,
+so feel free to drop your questions there as well.
 
 
 Posting patches
 ===============
 
 As already mentioned, we are accepting patches! And we are very happy
-for every contribution. If you're going to send a path in, please make
-sure to follow some simple rules:
+for every contribution. If you're going to send a patch in, please
+make sure to follow some simple rules:
 
 1. Before you're going to post a patch, please run our regression
    testing suite to make sure that your change does not break someone
-   else work. See *Tests section*
+   else's work. See *Tests section*
 
 2. If you're making a change that might require documentation update,
    please update the documentation as well. See *Documentation
    section*
 
-3. Make sure your patch have all the requisites such as *short
+3. Make sure your patch has all the requisites such as a *short
    description* preferably 50 characters long at max describing the
    main idea of the change. *Long description* describing what was
    changed with and why and finally Signed-off-by tag.
diff --git a/bin/ssm b/bin/ssm
index 6058f64..dc75bf8 100755
--- a/bin/ssm
+++ b/bin/ssm
@@ -46,9 +46,9 @@ try:
             if not os.geteuid() == 0:
                 sys.exit("\nRoot privileges required to run this script!\n")
         sys.exit(main.main())
-except problem.SsmError, err:
+except problem.SsmError as err:
     if SSM_PRINT_BACKTRACE is True:
         traceback.print_exc(file=sys.stdout)
     else:
-        print str(err)
+        print(str(err))
     sys.exit(err.errcode)
diff --git a/bin/ssm.local b/bin/ssm.local
index 9ef4db4..9669e44 100755
--- a/bin/ssm.local
+++ b/bin/ssm.local
@@ -24,4 +24,4 @@
 SSMDIR="$( cd -P "$( dirname "${BASH_SOURCE[0]}" )/../" && pwd )"
 export PYTHONPATH="$SSMDIR"
 
-python $SSMDIR/bin/ssm $@
+python $SSMDIR/bin/ssm "$@"
diff --git a/doc/_build/man/ssm.8 b/doc/_build/man/ssm.8
index ab777bf..f19d977 100644
--- a/doc/_build/man/ssm.8
+++ b/doc/_build/man/ssm.8
@@ -1,6 +1,6 @@
 .\" Man page generated from reStructuredText.
 .
-.TH "SSM" "8" "October 02, 2013" "0.4" "System Storage Manager"
+.TH "SSM" "8" "July 01, 2016" "0.4" "System Storage Manager"
 .SH NAME
 ssm \- System Storage Manager: a single tool to manage your storage
 .
@@ -61,7 +61,7 @@ level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
 .sp
 \fBssm\fP [\fB\-h\fP] [\fB\-\-version\fP] [\fB\-v\fP] [\fB\-f\fP] [\fB\-b\fP BACKEND] [\fB\-n\fP] {check,resize,create,list,add,remove,snapshot,mount} ...
 .sp
-\fBssm\fP \fBcreate\fP [\fB\-h\fP] [\fB\-s\fP SIZE] [\fB\-n\fP NAME] [\fB\-\-fstype\fP FSTYPE] [\fB\-r\fP LEVEL] [\fB\-I\fP STRIPESIZE] [\fB\-i\fP STRIPES] [\fB\-p\fP POOL] [\fB\-e\fP [{luks,plain}]] [\fBdevice\fP [\fBdevice\fP ...]] [mount]
+\fBssm\fP \fBcreate\fP [\fB\-h\fP] [\fB\-s\fP SIZE] [\fB\-n\fP NAME] [\fB\-\-fstype\fP FSTYPE] [\fB\-r\fP LEVEL] [\fB\-I\fP STRIPESIZE] [\fB\-i\fP STRIPES] [\fB\-p\fP POOL] [\fB\-e\fP [{luks,plain}]] [\fB\-o\fP MNT_OPTIONS] [\fB\-v\fP VIRTUAL_SIZE] [\fBdevice\fP [\fBdevice\fP ...]] [mount]
 .sp
 \fBssm\fP \fBlist\fP [\fB\-h\fP] [{volumes,vol,dev,devices,pool,pools,fs,filesystems,snap,snapshots}]
 .sp
@@ -78,9 +78,9 @@ level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
 \fBssm\fP \fBmount\fP [\fB\-h\fP] [\fB\-o\fP OPTIONS] \fBvolume\fP directory
 .SH DESCRIPTION
 .sp
-System Storage Manager provides easy to use command line interface to manage
-your storage using various technologies like lvm, btrfs, encrypted volumes and
-more.
+System Storage Manager provides an easy to use command line interface to
+manage your storage using various technologies like lvm, btrfs, encrypted
+volumes and more.
 .sp
 In more sophisticated enterprise storage environments, management with Device
 Mapper (dm), Logical Volume Manager (LVM), or Multiple Devices (md) is
@@ -118,54 +118,71 @@ line options and gather system information if
 necessary. Note that with this option ssm will not
 perform all the check as some of them are done by the
 backends themselves. This option is mainly used for
-debugging purposes.
+debugging purposes, but still requires root
+privileges.
 .UNINDENT
 .SH SYSTEM STORAGE MANAGER COMMANDS
 .SS Introduction
 .sp
-System Storage Manager have several commands you can specify on the command
-line as a first argument to the ssm. They all have specific use and its own
-arguments, but global ssm arguments are propagated to all commands.
+System Storage Manager has several commands that you can specify on the
+command line as a first argument to ssm. They all have a specific use and
+their own arguments, but global ssm arguments are propagated to all commands.
 .SS Create command
 .sp
-\fBssm\fP \fBcreate\fP [\fB\-h\fP] [\fB\-s\fP SIZE] [\fB\-n\fP NAME] [\fB\-\-fstype\fP FSTYPE] [\fB\-r\fP LEVEL] [\fB\-I\fP STRIPESIZE] [\fB\-i\fP STRIPES] [\fB\-p\fP POOL] [\fB\-e\fP [{luks,plain}]] [\fBdevice\fP [\fBdevice\fP ...]] [mount]
+\fBssm\fP \fBcreate\fP [\fB\-h\fP] [\fB\-s\fP SIZE] [\fB\-n\fP NAME] [\fB\-\-fstype\fP FSTYPE] [\fB\-r\fP LEVEL] [\fB\-I\fP STRIPESIZE] [\fB\-i\fP STRIPES] [\fB\-p\fP POOL] [\fB\-e\fP [{luks,plain}]] [\fB\-o\fP MNT_OPTIONS] [\fB\-v\fP VIRTUAL_SIZE] [\fBdevice\fP [\fBdevice\fP ...]] [mount]
 .sp
-This command creates a new volume with defined parameters. If \fBdevice\fP is
-provided it will be used to create a volume, hence it will be added into the
-\fBpool\fP prior the volume creation (See \fIAdd command section\fP). More devices can be used to create a volume.
+This command creates a new volume with defined parameters. If a \fBdevice\fP is
+provided it will be used to create the volume, hence it will be added into the
+\fBpool\fP prior to volume creation (See \fIAdd command section\fP). More than one device can be used to create a volume.
 .sp
-If the \fBdevice\fP is already used in the different pool, then \fBssm\fP will
+If the \fBdevice\fP is already being used in a different pool, then \fBssm\fP will
 ask you whether you want to remove it from the original pool. If you decline,
-or the removal fails, then the \fBvolume\fP creation fails if the \fISIZE\fP was
-not provided. On the other hand, if the \fISIZE\fP is provided and some devices
-can not be added to the \fBpool\fP the volume creation might succeed if there
+or the removal fails, then the \fBvolume\fP creation fails if the \fISIZE\fP was not
+provided. On the other hand, if the \fISIZE\fP is provided and some devices can
+not be added to the \fBpool\fP, the volume creation might still succeed if there
 is enough space in the \fBpool\fP\&.
 .sp
-\fIPOOL\fP name can be specified as well. If the pool exists new volume will be
-created from that pool (optionally adding \fBdevice\fP into the pool). However
-if the \fIPOOL\fP does not exist \fBssm\fP will attempt to create a new pool with
-provided \fBdevice\fP and then create a new volume from this pool. If
-\fB\-\-backend\fP argument is omitted, the default \fBssm\fP backend will be used.
-Default backend is \fIlvm\fP\&.
+In addition to specifying size of the volume directly, percentage can be
+specified as well. Specify \fB\-\-size 70%\fP to indicate the volume size to be
+70% of total pool size. Additionally, percentage of the used, or free pool
+space can be specified as well using keywords FREE, or USED respectively.
 .sp
-\fBssm\fP also supports creating RAID configuration, however some back\-ends
-might not support all the levels, or it might not support RAID at all. In
+The \fIPOOL\fP name can be specified as well. If the pool exists, a new volume
+will be created from that pool (optionally adding \fBdevice\fP into the pool).
+However if the \fIPOOL\fP does not exist, then \fBssm\fP will attempt to create a
+new pool with the provided \fBdevice\fP, and then create a new volume from this
+pool. If the \fB\-\-backend\fP argument is omitted, the default \fBssm\fP backend
+will be used. The default backend is \fIlvm\fP\&.
+.sp
+\fBssm\fP also supports creating a RAID configuration, however some back\-ends
+might not support all RAID levels, or may not even support RAID at all. In
 this case, volume creation will fail.
 .sp
-If \fBmount\fP point is provided \fBssm\fP will attempt to mount the volume after
-it is created. However it will fail if mountable file system is not present
-on the volume.
+If a \fBmount\fP point is provided, \fBssm\fP will attempt to mount the volume
+after it is created. However it will fail if mountable file system is not
+present on the volume.
+.sp
+If the backend allows it (currently only supported with \fBlvm\fP backend),
+\fBssm\fP can be used to create \fBthinly provisioned volumes\fP by specifying
+\fB\-\-virtual\-size\fP option. This will automatically create a \fBthin pool\fP of
+a given size provided with \fB\-\-size\fP option and \fBthin volume\fP of a given
+size provided with \fB\-\-virtual\-size\fP option and name provided with \fB\-\-name\fP
+option. Virtual size can be much bigger than available space in the \fBpool\fP\&.
 .INDENT 0.0
 .TP
 .B \-h\fP,\fB  \-\-help
 show this help message and exit
 .TP
 .BI \-s \ SIZE\fP,\fB \ \-\-size \ SIZE
-Gives the size to allocate for the new logical volume
+Gives the size to allocate for the new logical volume.
 A size suffix K|k, M|m, G|g, T|t, P|p, E|e can be used
 to define \(aqpower of two\(aq units. If no unit is
 provided, it defaults to kilobytes. This is optional
-if if not given maximum possible size will be used.
+and if not given, maximum possible size will be used.
+Additionally the new size can be specified as a
+percentage of the total pool size (50%), as a
+percentage of free pool space (50%FREE), or as a
+percentage of used pool space (50%USED).
 .TP
 .BI \-n \ NAME\fP,\fB \ \-\-name \ NAME
 The name for the new logical volume. This is optional
@@ -209,23 +226,36 @@ Pool to use to create the new volume.
 Create encrpted volume. Extension to use can be
 specified.
 .UNINDENT
+.INDENT 0.0
+.TP
+.BI \-o \ MNT_OPTIONS\fP,\fB \ \-\-mnt\-options \ MNT_OPTIONS
+Mount options are specified with a \-o flag followed by
+a comma separated string of options. This option is
+equivalent to the \-o mount(8) option.
+.TP
+.BI \-v \ VIRTUAL_SIZE\fP,\fB \ \-\-virtual\-size \ VIRTUAL_SIZE
+Gives the virtual size for the new thinly provisioned
+volume. A size suffix K|k, M|m, G|g, T|t, P|p, E|e can
+be used to define \(aqpower of two\(aq units. If no unit is
+provided, it defaults to kilobytes.
+.UNINDENT
 .SS List command
 .sp
 \fBssm\fP \fBlist\fP [\fB\-h\fP] [{volumes,vol,dev,devices,pool,pools,fs,filesystems,snap,snapshots}]
 .sp
-List informations about all detected devices, pools, volumes and snapshots found
-in the system. \fBlist\fP command can be used either alone to list all the
-information, or you can request specific section only.
+Lists information about all detected devices, pools, volumes and snapshots found
+on the system. The \fBlist\fP command can be used either alone to list all of the
+information, or you can request specific sections only.
 .sp
-Following sections can be specified:
+The following sections can be specified:
 .INDENT 0.0
 .TP
 .B {volumes | vol}
 List information about all \fBvolumes\fP found in the system.
 .TP
 .B {devices | dev}
-List information about all \fBdevices\fP found in the system. Some devices are
-intentionally hidden, like for example cdrom, or DM/MD devices since those
+List information about all \fBdevices\fP found on the system. Some devices
+are intentionally hidden, like for example cdrom or DM/MD devices since those
 are actually listed as volumes.
 .TP
 .B {pools | pool}
@@ -236,12 +266,12 @@ List information about all volumes containing \fBfilesystems\fP found in
 the system.
 .TP
 .B {snapshots | snap}
-List information about all \fBsnapshots\fP found in the system. Note that some
-back\-ends does not support snapshotting and some can not distinguish between
-snapshot and regular volume. in this case \fBssm\fP will try to recognize
-volume name in order to identify \fBsnapshot\fP, but if the \fBssm\fP regular
-expression does not match the snapshot pattern, this snapshot will not be
-recognized.
+List information about all \fBsnapshots\fP found in the system. Note that
+some back\-ends do not support snapshotting and some cannot distinguish
+snapshot from regular volumes. In this case, \fBssm\fP will try to recognize the
+volume name in order to identify a \fBsnapshot\fP, but if the \fBssm\fP regular
+expression does not match the snapshot pattern, the problematic snapshot will
+not be recognized.
 .UNINDENT
 .INDENT 0.0
 .TP
@@ -252,25 +282,26 @@ show this help message and exit
 .sp
 \fBssm\fP \fBremove\fP [\fB\-h\fP] [\fB\-a\fP] [\fBitems\fP [\fBitems\fP ...]]
 .sp
-This command removes \fBitem\fP from the system. Multiple items can be specified.
-If the \fBitem\fP can not be removed for some reason, it will be skipped.
+This command removes an \fBitem\fP from the system. Multiple items can be
+specified.  If the \fBitem\fP cannot be removed for some reason, it will be
+skipped.
 .sp
-\fBitem\fP can represent:
+An \fBitem\fP can be any of the following:
 .INDENT 0.0
 .TP
 .B device
-Remove \fBdevice\fP from the pool. Note that this can not be done in some
-cases where the device is used by pool. You can use \fB\-f\fP argument to
+Remove a \fBdevice\fP from the pool. Note that this cannot be done in some
+cases where the device is being used by the pool. You can use the \fB\-f\fP argument to
 \fIforce\fP removal. If the device does not belong to any pool, it will be
 skipped.
 .TP
 .B pool
-Remove the \fBpool\fP from the system. This will also remove all volumes
+Remove a \fBpool\fP from the system. This will also remove all volumes
 created from that pool.
 .TP
 .B volume
-Remove the \fBvolume\fP from the system. Note that this will fail if the
-\fBvolume\fP is mounted and it can not be \fIforced\fP with \fB\-f\fP\&.
+Remove a \fBvolume\fP from the system. Note that this will fail if the
+\fBvolume\fP is mounted and cannot be \fIforced\fP with \fB\-f\fP\&.
 .UNINDENT
 .INDENT 0.0
 .TP
@@ -284,16 +315,21 @@ Remove all pools in the system.
 .sp
 \fBssm\fP \fBresize\fP [\fB\-h\fP] [\fB\-s\fP SIZE] \fBvolume\fP [\fBdevice\fP [\fBdevice\fP ...]]
 .sp
-Change size of the \fBvolume\fP and file system. If there is no file system only
-the \fBvolume\fP itself will be resized. You can specify \fBdevice\fP to add into
-the \fBvolume\fP pool prior the resize. Note that \fBdevice\fP will only be added
+Change size of the \fBvolume\fP and file system. If there is no file system, only
+the \fBvolume\fP itself will be resized. You can specify a \fBdevice\fP to add into
+the \fBvolume\fP pool prior the resize. Note that the \fBdevice\fP will only be added
 into the pool if the \fBvolume\fP size is going to grow.
 .sp
-If the \fBdevice\fP is already used in the different pool, then \fBssm\fP will
-ask you whether you want to remove it from the original pool.
+If the \fBdevice\fP is already used in a different pool, then \fBssm\fP will
+ask you whether or not you want to remove it from the original pool.
 .sp
-In some cases file system has to be mounted in order to resize. This will be
-handled by \fBssm\fP automatically by mounting the \fBvolume\fP temporarily.
+In some cases, the file system has to be mounted in order to resize. This will
+be handled by \fBssm\fP automatically by mounting the \fBvolume\fP temporarily.
+.sp
+In addition to specifying new size of the volume directly, percentage can be
+specified as well. Specify \fB\-\-size 70%\fP to resize the volume to 70% of it\(aqs
+original size. Additionally, percentage of the used, or free pool space can
+be specified as well using keywords FREE, or USED respectively.
 .sp
 Note that resizing btrfs subvolume is not supported, only the whole file
 system can be resized.
@@ -310,6 +346,10 @@ new volume size. A size suffix of [k|K] for kilobytes,
 [m|M] for megabytes, [g|G] for gigabytes, [t|T] for
 terabytes or [p|P] for petabytes is optional. If no
 unit is provided the default is kilobytes.
+Additionally the new size can be specified as a
+percentage of the original volume size ([+][\-]50%), as
+a percentage of free pool space ([+][\-]50%FREE), or as
+a percentage of used pool space ([+][\-]50%USED).
 .UNINDENT
 .SS Check command
 .sp
@@ -319,9 +359,9 @@ Check the file system consistency on the \fBvolume\fP\&. You can specify multipl
 volumes to check. If there is no file system on the \fBvolume\fP, this \fBvolume\fP
 will be skipped.
 .sp
-In some cases file system has to be mounted in order to check the file system
-This will be handled by \fBssm\fP automatically by mounting the \fBvolume\fP
-temporarily.
+In some cases the file system has to be mounted in order to check the file
+system.  This will be handled by \fBssm\fP automatically by mounting the
+\fBvolume\fP temporarily.
 .INDENT 0.0
 .TP
 .B \-h\fP,\fB  \-\-help
@@ -331,12 +371,18 @@ show this help message and exit
 .sp
 \fBssm\fP \fBsnapshot\fP [\fB\-h\fP] [\fB\-s\fP SIZE] [\fB\-d\fP DEST | \fB\-n\fP NAME] volume
 .sp
-Take a snapshot of existing \fBvolume\fP\&. This operation will fail if back\-end
-which the \fBvolume\fP belongs to does not support snapshotting. Note that
-you can not specify both \fINAME\fP and \fIDESC\fP since those options are mutually
-exclusive.
+Take a snapshot of an existing \fBvolume\fP\&. This operation will fail if the
+back\-end to which the \fBvolume\fP belongs to does not support snapshotting.
+Note that you cannot specify both \fINAME\fP and \fIDEST\fP since those options are
+mutually exclusive.
 .sp
-In some cases file system has to be mounted in order to take a snapshot of
+In addition to specifying new size of the volume directly, percentage can be
+specified as well. Specify \fB\-\-size 70%\fP to indicate the new snapshot size
+to be 70% of the origin volume size. Additionally, percentage of the used,
+or free pool space can be specified as well using keywords FREE, or USED
+respectively.
+.sp
+In some cases the file system has to be mounted in order to take a snapshot of
 the \fBvolume\fP\&. This will be handled by \fBssm\fP automatically by mounting the
 \fBvolume\fP temporarily.
 .INDENT 0.0
@@ -345,12 +391,15 @@ the \fBvolume\fP\&. This will be handled by \fBssm\fP automatically by mounting
 show this help message and exit
 .TP
 .BI \-s \ SIZE\fP,\fB \ \-\-size \ SIZE
-Gives the size to allocate for the new snapshot volume
-A size suffix K|k, M|m, G|g, T|t, P|p, E|e can be used
-to define \(aqpower of two\(aq units. If no unit is
-provided, it defaults to kilobytes. This is option and
-if not give, the size will be determined
-automatically.
+Gives the size to allocate for the new snapshot
+volume. A size suffix K|k, M|m, G|g, T|t, P|p, E|e can
+be used to define \(aqpower of two\(aq units. If no unit is
+provided, it defaults to kilobytes. This is optional
+and if not given, the size will be determined
+automatically. Additionally the new size can be
+specified as a percentage of the original volume size
+(50%), as a percentage of free pool space (50%FREE),
+or as a percentage of used pool space (50%USED).
 .TP
 .BI \-d \ DEST\fP,\fB \ \-\-dest \ DEST
 Destination of the snapshot specified with absolute
@@ -366,13 +415,13 @@ specified default backend policy will be performed.
 .sp
 \fBssm\fP \fBadd\fP [\fB\-h\fP] [\fB\-p\fP POOL] \fBdevice\fP [\fBdevice\fP ...]
 .sp
-This command adds \fBdevice\fP into the pool. The \fBdevice\fP will not be added if
-it\(aqs already part of different pool by default, but user will be asked whether
-to remove the device from it\(aqs pool. When multiple devices are provided,
-all of them are added into the pool. If one of the devices can not be added
-into the pool for any reason, add command will fail. If no pool is specified,
-default pool will be chosen. In the case of non existing pool, it will be
-created using provided devices.
+This command adds a \fBdevice\fP into the pool. By default, the \fBdevice\fP will
+not be added if it\(aqs already a part of a different pool, but the user will be
+asked whether or not to remove the device from its pool. When multiple devices
+are provided, all of them are added into the pool. If one of the devices
+cannot be added into the pool for any reason, the add command will fail. If no
+pool is specified, the default pool will be chosen. In the case of a non
+existing pool, it will be created using the provided devices.
 .INDENT 0.0
 .TP
 .B \-h\fP,\fB  \-\-help
@@ -386,13 +435,13 @@ pool is used.
 .sp
 \fBssm\fP \fBmount\fP [\fB\-h\fP] [\fB\-o\fP OPTIONS] \fBvolume\fP directory
 .sp
-This command will mount the \fBvolume\fP at specified \fBdirectory\fP\&. The
-\fBvolume\fP can be specified in the same way as with \fBmount(8)\fP, however
-in addition one can also specify \fBvolume\fP in the format as it appear in
-the \fBssm list\fP table.
+This command will mount the \fBvolume\fP at the specified \fBdirectory\fP\&. The
+\fBvolume\fP can be specified in the same way as with \fBmount(8)\fP, however in
+addition, one can also specify a \fBvolume\fP in the format as it appears in the
+\fBssm list\fP table.
 .sp
 For example, instead of finding out what the device and subvolume id of the
-btrfs subvolume "btrfs_pool:vol001" is in order to mount it, on can simply
+btrfs subvolume "btrfs_pool:vol001" is in order to mount it, one can simply
 call \fBssm mount btrfs_pool:vol001 /mnt/test\fP\&.
 .sp
 One can also specify \fIOPTIONS\fP in the same way as with \fBmount(8)\fP\&.
@@ -409,14 +458,14 @@ equivalent to the same mount(8) option.
 .SH BACK-ENDS
 .SS Introduction
 .sp
-Ssm aims to create unified user interface for various technologies like Device
+Ssm aims to create a unified user interface for various technologies like Device
 Mapper (dm), Btrfs file system, Multiple Devices (md) and possibly more. In
 order to do so we have a core abstraction layer in \fBssmlib/main.py\fP\&. This
 abstraction layer should ideally know nothing about the underlying technology,
-but rather comply with \fBdevice\fP, \fBpool\fP and \fBvolume\fP abstraction.
+but rather comply with \fBdevice\fP, \fBpool\fP and \fBvolume\fP abstractions.
 .sp
 Various backends can be registered in \fBssmlib/main.py\fP in order to handle
-specific storage technology implementing methods like \fIcreate\fP, \fIsnapshot\fP, or
+specific storage technology, implementing methods like \fIcreate\fP, \fIsnapshot\fP, or
 \fIremove\fP volumes and pools. The core will then call these methods to manage
 the storage without needing to know what lies underneath it. There are already
 several backends registered in ssm.
@@ -432,61 +481,60 @@ is what it means from the btrfs point of view:
 .INDENT 0.0
 .TP
 .B pool
-Pool is actually a btrfs file system itself, because it can be extended
-by adding more devices, or shrink by removing devices from it. Subvolumes
-and snapshots can also be created. When the new btrfs pool should be created
-\fBssm\fP simply creates a btrfs file system, which means that every new
-btrfs pool has one volume of the same name as the pool itself which can
-not be removed without removing the entire pool. Default btrfs pool name is
-\fBbtrfs_pool\fP\&.
-.sp
-When creating new btrfs pool, the name of the pool is used as the file
-system label. If there is already existing btrfs file system in the system
-without a label, btrfs pool name will be generated for internal use
-in the following format "btrfs_{device base name}".
-.sp
-Btrfs pool is created when \fBcreate\fP or \fBadd\fP command is used with
-devices specified and non existing pool name.
+A pool is actually a btrfs file system itself, because it can be extended
+by adding more devices, or shrunk by removing devices from it. Subvolumes
+and snapshots can also be created. When the new btrfs pool should be
+created, \fBssm\fP simply creates a btrfs file system, which means that every
+new btrfs pool has one volume of the same name as the pool itself which can
+not be removed without removing the entire pool. The default btrfs pool
+name is \fBbtrfs_pool\fP\&.
+.sp
+When creating a new btrfs pool, the name of the pool is used as the file
+system label. If there is an already existing btrfs file system in the system
+without a label, a btrfs pool name will be generated for internal use in the
+following format "btrfs_{device base name}".
+.sp
+A btrfs pool is created when the \fBcreate\fP or \fBadd\fP command is used
+with specified devices and non existing pool name.
 .TP
 .B volume
-Volume in btrfs back\-end is actually just btrfs subvolume with the
-exception of the first volume created on btrfs pool creation, which is
-the file system itself. Subvolumes can only be created on btrfs file
-system when it is mounted, but user does not have to
-worry about that since \fBssm\fP will automatically mount the file
-system temporarily in order to create a new subvolume.
-.sp
-Volume name is used as subvolume path in the btrfs file system and every
-object in this path must exists in order to create a volume. Volume name
-for internal tracking and for representing to the user is generated in
-the format "{pool_name}:{volume name}", but volumes can be also referenced
-with its mount point.
-.sp
-Btrfs volumes are only shown in the \fIlist\fP output, when the file system is
+A volume in the btrfs back\-end is actually just btrfs subvolume with the
+exception of the first volume created on btrfs pool creation, which is the
+file system itself. Subvolumes can only be created on the btrfs file system
+when it is mounted, but the user does not have to worry about that since
+\fBssm\fP will automatically mount the file system temporarily in order to
+create a new subvolume.
+.sp
+The volume name is used as subvolume path in the btrfs file system and
+every object in this path must exist in order to create a volume. The volume
+name for internal tracking and that is visible to the user is generated in the
+format "{pool_name}:{volume name}", but volumes can be also referenced by its
+mount point.
+.sp
+The btrfs volumes are only shown in the \fIlist\fP output, when the file system is
 mounted, with the exception of the main btrfs volume \- the file system
 itself.
 .sp
-Also note that btrfs volumes and subvolumes can not be resized. This is
-mainly limitation of the btrfs tools which currently does not work
-reliably.
+Also note that btrfs volumes and subvolumes cannot be resized. This is
+mainly limitation of the btrfs tools which currently do not work reliably.
 .sp
-New btrfs volume can be created with \fBcreate\fP command.
+A new btrfs volume can be created with the \fBcreate\fP command.
 .TP
 .B snapshot
-Btrfs file system support subvolume snapshotting, so you can take a snapshot
-of any btrfs volume in the system with \fBssm\fP\&. However btrfs does not
-distinguish between subvolumes and snapshots, because snapshot actually is
-just a subvolume with some block shared with different subvolume. It means,
-that \fBssm\fP is not able to recognize btrfs snapshot directly, but instead
-it is trying to recognize special name format of the btrfs volume. However,
-if the \fINAME\fP is specified when creating snapshot which does not match the
-special pattern, snapshot will not be recognized by the \fBssm\fP and it will
-be listed as regular btrfs volume.
-.sp
-New btrfs snapshot can be created with \fBsnapshot\fP command.
+The btrfs file system supports subvolume snapshotting, so you can take a
+snapshot of any btrfs volume in the system with \fBssm\fP\&. However btrfs does
+not distinguish between subvolumes and snapshots, because a snapshot is
+actually just a subvolume with some blocks shared with a different subvolume.
+This means, that \fBssm\fP is not able to directly recognize a btrfs snapshot.
+Instead, \fBssm\fP will try to recognize a special name format of the btrfs
+volume that denotes it is a snapshot. However, if the \fINAME\fP is specified when
+creating snapshot which does not match the special pattern, snapshot will not
+be recognized by the \fBssm\fP and it will be listed as regular btrfs volume.
+.sp
+A new btrfs snapshot can be created with the \fBsnapshot\fP command.
 .TP
 .B device
-Btrfs does not require any special device to be created on.
+Btrfs does not require a special device to be created on.
 .UNINDENT
 .SS Lvm backend
 .sp
@@ -495,32 +543,35 @@ the lvm abstraction.
 .INDENT 0.0
 .TP
 .B pool
-Lvm pool is just \fIvolume group\fP in lvm language. It means that it is
-grouping devices and new logical volumes can be created out of the lvm
-pool. Default lvm pool name is \fBlvm_pool\fP\&.
+An lvm pool is just a \fIvolume group\fP in lvm language. It means that it is
+grouping devices and new logical volumes can be created out of the lvm pool.
+The default lvm pool name is \fBlvm_pool\fP\&.
 .sp
-Lvm pool is created when \fBcreate\fP or \fBadd\fP command is used with
-devices specified and non existing pool name.
+An lvm pool is created when the \fBcreate\fP or \fBadd\fP commands are used
+with specified devices and a non existing pool name.
+.sp
+Alternatively a \fBthin pool\fP can be created as a result of using
+\fB\-\-virtual\-size\fP option to create \fBthin volume\fP\&.
 .TP
 .B volume
-Lvm volume is just \fIlogical volume\fP in lvm language. Lvm volume can be
-created wit \fBcreate\fP command.
+An lvm volume is just a \fIlogical volume\fP in lvm language. An lvm volume
+can be created with the \fBcreate\fP command.
 .TP
 .B snapshot
 Lvm volumes can be snapshotted as well. When a snapshot is created from
-the lvm volume, new \fIsnapshot\fP volume is created, which can be handled as
+the lvm volume, a new \fIsnapshot\fP volume is created, which can be handled as
 any other lvm volume. Unlike \fIbtrfs\fP lvm is able
 to distinguish snapshot from regular volume, so there is no need for a
 snapshot name to match special pattern.
 .TP
 .B device
-Lvm requires \fIphysical device\fP to be created on the device, but with
+Lvm requires a \fIphysical device\fP to be created on the device, but with
 \fBssm\fP this is transparent for the user.
 .UNINDENT
 .SS Crypt backend
 .sp
-Crypt backend in \fBssm\fP uses cryptsetup and dm\-crypt target to manage
-encrypted volumes. Crypt backend can be used as a regular backend for
+The crypt backend in \fBssm\fP uses cryptsetup and dm\-crypt target to manage
+encrypted volumes. The crypt backend can be used as a regular backend for
 creating encrypted volumes on top of regular block devices, or even other
 volumes (lvm or md volumes for example). Or it can be used to create
 encrypted lvm volumes right away in a single step.
@@ -530,35 +581,35 @@ support pooling and does not require special devices.
 .INDENT 0.0
 .TP
 .B pool
-Crypt backend does not support pooling it is not possible to create
-crypt pool or add a device into a pool.
+The crypt backend does not support pooling, and it is not possible to
+create crypt pool or add a device into a pool.
 .TP
 .B volume
-Volume in crypt backend is the volume created by dm\-crypt which
-represent the data on the original encrypted device in unencrypted form.
-Crypt backend does not support pooling, so only one device can be used
+A volume in the crypt backend is the volume created by dm\-crypt which
+represents the data on the original encrypted device in unencrypted form.
+The crypt backend does not support pooling, so only one device can be used
 to create crypt volume. It also does not support raid or any device
 concatenation.
 .sp
-Currently two modes, or extensions are supported luks and plain. Luks
-is used by default.For more information about the extensions please see
+Currently two modes, or extensions are supported: luks and plain. Luks
+is used by default. For more information about the extensions, please see
 \fBcryptsetup\fP manual page.
 .TP
 .B snapshot
-Crypt backend does not support snapshotting, however if the encrypted
-volume is created on top of the lvm volume, the lvm volume itself can
+The crypt backend does not support snapshotting, however if the encrypted
+volume is created on top of an lvm volume, the lvm volume itself can
 be snapshotted. The snapshot can be then opened by using \fBcryptsetup\fP\&.
 It is possible that this might change in the future so that \fBssm\fP will
 be able to activate the volume directly without the extra step.
 .TP
 .B device
-Crypt backend does not require any special device to be created on.
+The crypt backend does not require a special device to be created on.
 .UNINDENT
 .SS MD backend
 .sp
 MD backend in \fBssm\fP is currently limited to only gather the information
 about MD volumes in the system. You can not create or manage MD volumes
-or pools, but it will be extended in the future.
+or pools, but this functionality will be extended in the future.
 .SH EXAMPLES
 .sp
 \fBList\fP system storage information:
@@ -585,7 +636,7 @@ or pools, but it will be extended in the future.
 .UNINDENT
 .UNINDENT
 .sp
-\fBCreate\fP a new 100GB \fBvolume\fP with default lvm backend using \fI/dev/sda\fP and
+\fBCreate\fP a new 100GB \fBvolume\fP with the default lvm backend using \fI/dev/sda\fP and
 \fI/dev/sdb\fP with xfs file system:
 .INDENT 0.0
 .INDENT 3.5
@@ -598,7 +649,7 @@ or pools, but it will be extended in the future.
 .UNINDENT
 .UNINDENT
 .sp
-\fBCreate\fP a new \fBvolume\fP with btrfs backend using \fI/dev/sda\fP and \fI/dev/sdb\fP and
+\fBCreate\fP a new \fBvolume\fP with a btrfs backend using \fI/dev/sda\fP and \fI/dev/sdb\fP and
 let the volume to be RAID 1:
 .INDENT 0.0
 .INDENT 3.5
@@ -611,7 +662,7 @@ let the volume to be RAID 1:
 .UNINDENT
 .UNINDENT
 .sp
-Using lvm backend \fBcreate\fP a RAID 0 \fBvolume\fP with devices \fI/dev/sda\fP and
+Using the lvm backend \fBcreate\fP a RAID 0 \fBvolume\fP with devices \fI/dev/sda\fP and
 \fI/dev/sdb\fP with 128kB stripe size, ext4 file system and mount it on
 \fI/home\fP:
 .INDENT 0.0
@@ -625,6 +676,32 @@ Using lvm backend \fBcreate\fP a RAID 0 \fBvolume\fP with devices \fI/dev/sda\fP
 .UNINDENT
 .UNINDENT
 .sp
+\fBCreate\fP a new \fBthinly provisioned volume\fP with a lvm backend using devices
+\fI/dev/sda\fP and \fI/dev/sdb\fP using \fI\-\-virtual\-size\fP option:
+.INDENT 0.0
+.INDENT 3.5
+.sp
+.nf
+.ft C
+# ssm create \-\-virtual\-size 1T /dev/sda /dev/sdb
+.ft P
+.fi
+.UNINDENT
+.UNINDENT
+.sp
+\fBCreate\fP a new \fBthinly provisioned volume\fP with a defined \fBthin pool\fP
+size and devices \fI/dev/sda\fP and \fI/dev/sdb\fP:
+.INDENT 0.0
+.INDENT 3.5
+.sp
+.nf
+.ft C
+# ssm create \-\-size 50G \-\-virtual\-size 1T /dev/sda /dev/sdb
+.ft P
+.fi
+.UNINDENT
+.UNINDENT
+.sp
 \fBExtend\fP btrfs \fBvolume\fP \fIbtrfs_pool\fP by 500GB and use \fI/dev/sdc\fP and
 \fI/dev/sde\fP to cover the resize:
 .INDENT 0.0
@@ -703,21 +780,21 @@ Using lvm backend \fBcreate\fP a RAID 0 \fBvolume\fP with devices \fI/dev/sda\fP
 .TP
 .B SSM_DEFAULT_BACKEND
 Specify which backend will be used by default. This can be overridden by
-specifying \fB\-b\fP or \fB\-\-backend\fP argument. Currently only \fIlvm\fP and \fIbtrfs\fP
-is supported.
+specifying the \fB\-b\fP or \fB\-\-backend\fP argument. Currently only \fIlvm\fP and
+\fIbtrfs\fP are supported.
 .TP
 .B SSM_LVM_DEFAULT_POOL
-Name of the default lvm pool to be used if \fB\-p\fP or \fB\-\-pool\fP argument
-is omitted.
+Name of the default lvm pool to be used if the \fB\-p\fP or \fB\-\-pool\fP
+argument is omitted.
 .TP
 .B SSM_BTRFS_DEFAULT_POOL
-Name of the default btrfs pool to be used if \fB\-p\fP or \fB\-\-pool\fP argument
-is omitted.
+Name of the default btrfs pool to be used if the \fB\-p\fP or \fB\-\-pool\fP
+argument is omitted.
 .TP
 .B SSM_PREFIX_FILTER
-When this is set \fBssm\fP will filter out all devices, volumes and pools
-which name does not start with this prefix. It is used mainly in \fBssm\fP
-test suite to make sure that we do not scramble local system
+When this is set, \fBssm\fP will filter out all devices, volumes and pools
+whose name does not start with this prefix. It is used mainly in the \fBssm\fP
+test suite to make sure that we do not scramble the local system
 configuration.
 .UNINDENT
 .SH LICENCE
@@ -739,11 +816,11 @@ along with this program.  If not, see <\fI\%http://www.gnu.org/licenses/\fP>.
 .SH REQUIREMENTS
 .sp
 Python 2.6 or higher is required to run this tool. System Storage Manager
-can only be run as root since most of the commands requires root privileges.
+can only be run as root since most of the commands require root privileges.
 .sp
-There are other requirements listed bellow, but note that you do not
-necessarily need all dependencies for all backends, however if some of the
-tools required by the backend is missing, the backend would not work.
+There are other requirements listed below, but note that you do not
+necessarily need all dependencies for all backends. However if some of the
+tools required by a backend are missing, that backend will not work.
 .SS Python modules
 .INDENT 0.0
 .IP \(bu 2
@@ -811,8 +888,8 @@ cryptsetup
 \fI\%http://storagemanager.sourceforge.net\fP\&. You can subscribe to
 \fI\%storagemanager-devel@lists.sourceforge.net\fP to follow the current development.
 .SH AUTHOR
-Luk Czerner <lczerner@redhat.com>
+Luk Czerner <lczerner@redhat.com>
 .SH COPYRIGHT
-2012, Red Hat, Inc., Luk Czerner <lczerner@redhat.com>
+2015, Red Hat, Inc., Luk Czerner <lczerner@redhat.com>
 .\" Generated by docutils manpage writer.
 .
diff --git a/setup.py b/setup.py
index 58a45a3..2aa14bb 100644
--- a/setup.py
+++ b/setup.py
@@ -8,8 +8,8 @@ DOC_BUILD='doc/_build/'
 NAME="system-storage-manager"
 
 if sys.version < '2.6':
-    print "Python version 2.6 or higher is required " + \
-         "for System Storage Manager to run correctly!"
+    print("Python version 2.6 or higher is required " +
+          "for System Storage Manager to run correctly!")
     sys.exit(1)
 
 setup(
@@ -32,4 +32,3 @@ setup(
                 ('/usr/share/doc/{0}-{1}'.format(NAME, VERSION),
                     ['README', 'CHANGES', 'COPYING', 'AUTHORS', 'INSTALL'])]
 )
-
diff --git a/ssmlib/backends/btrfs.py b/ssmlib/backends/btrfs.py
index 0483eb9..e5d5158 100644
--- a/ssmlib/backends/btrfs.py
+++ b/ssmlib/backends/btrfs.py
@@ -150,7 +150,7 @@ class Btrfs(template.Backend):
                 fs_size += float(misc.get_real_size(array[3]))
 
                 dev_size = \
-                    int(partitions[dev['dev_name'].rpartition("/")[-1]][2])
+                    int(partitions[dev['dev_name']][2])
                 pool_size += dev_size
                 dev['dev_free'] = dev_size - dev_used
                 self._dev[dev['dev_name']] = dev
@@ -203,7 +203,7 @@ class Btrfs(template.Backend):
             return
         if self._subvolumes:
             return
-        for name, vol in self._vol.iteritems():
+        for (name, vol) in self._vol.items():
             pool_name = vol['pool_name']
             real_dev = vol['real_dev']
             pool = self._pool[pool_name]
@@ -309,7 +309,7 @@ class Btrfs(template.Backend):
                                   [name, self._vol[name]['mount']]):
                 misc.do_umount(self._vol[name]['real_dev'], all_targets=True)
         devices = []
-        for dev in self._dev.itervalues():
+        for dev in self._dev.values():
             if dev['pool_name'] != name:
                 continue
             devices.append(dev['dev_name'])
@@ -374,8 +374,8 @@ class BtrfsVolume(Btrfs, template.BackendVolume):
         command = ['filesystem', 'resize', str(int(size)) + "K", vol['mount']]
         self.run_btrfs(command)
 
-    def snapshot(self, vol, destination, name, size, user_set_size):
-        vol = self.data[vol]
+    def snapshot(self, vol, destination, name, snap_size=None):
+        vol = self[vol]
         if 'mount' not in vol:
             tmp = misc.temp_mount("UUID={0}".format(vol['uuid']))
             vol['mount'] = tmp
@@ -386,7 +386,7 @@ class BtrfsVolume(Btrfs, template.BackendVolume):
         if name:
             destination = vol['mount'] + "/" + name
 
-        if user_set_size:
+        if snap_size:
             self.problem.warn("Btrfs doesn't allow setting a size of " +
                               "subvolumes")
 
@@ -563,7 +563,7 @@ class BtrfsSnap(Btrfs):
         super(BtrfsSnap, self).__init__(*args, **kwargs)
 
         self._fill_subvolumes(list_snapshots=True)
-        for name, vol in self._subvolumes.iteritems():
+        for (name, vol) in self._subvolumes.items():
             if BTRFS_VERSION < 0.20:
                 if 'snap_name' in vol:
                     self._snap[vol['snap_name']] = vol.copy()
diff --git a/ssmlib/backends/crypt.py b/ssmlib/backends/crypt.py
index 642b905..679d9c0 100644
--- a/ssmlib/backends/crypt.py
+++ b/ssmlib/backends/crypt.py
@@ -46,16 +46,18 @@ except KeyError:
 DM_DEV_DIR = "/dev"
 MAX_DEVS = 999
 
+
 def get_cryptsetup_version():
     try:
         output = misc.run(['cryptsetup', '--version'], can_fail=True)[1]
-        version = map(int, output.strip().split()[-1].split('.', 3))
+        version = list(map(int, output.strip().split()[-1].split('.', 3)))
     except (OSError, AttributeError):
         version = [0, 0, 0]
     return version
 
 CRYPTSETUP_VERSION = get_cryptsetup_version()
 
+
 class DmObject(template.Backend):
     def __init__(self, *args, **kwargs):
         super(DmObject, self).__init__(*args, **kwargs)
@@ -88,7 +90,6 @@ class DmCryptPool(DmObject, template.BackendPool):
         self.data[self.default_pool_name] = pool
         '''
 
-
     def create(self, pool, size=None, name=None, devs=None,
                options=None):
 
@@ -164,6 +165,8 @@ class DmCryptVolume(DmObject, template.BackendVolume):
                 break
             dm = {}
             array = line.split()
+            if len(array) == 1:
+                continue
             dm['type'] = array[3]
             if dm['type'] != 'crypt':
                 continue
@@ -200,7 +203,7 @@ class DmCryptVolume(DmObject, template.BackendVolume):
                 dm['crypt_device'] = array[1]
 
     def __getitem__(self, name):
-        if name in self.data.iterkeys():
+        if name in self.data:
             return self.data[name]
         device = name
         if not os.path.exists(name):
@@ -208,7 +211,7 @@ class DmCryptVolume(DmObject, template.BackendVolume):
             if not os.path.exists(device):
                 return None
         device = misc.get_real_device(device)
-        if device in self.data.iterkeys():
+        if device in self.data:
             return self.data[device]
         return None
 
@@ -235,7 +238,7 @@ class DmCryptDevice(DmObject, template.BackendDevice):
 
         for line in misc.get_partitions():
             device = {}
-            devname = "/dev/" + line[3]
+            devname = line[3]
             signature = misc.get_signature(devname)
             if signature in CRYPT_SIGNATURES:
                 device['hide'] = False
@@ -245,6 +248,5 @@ class DmCryptDevice(DmObject, template.BackendDevice):
                 device['dev_used'] = str(misc.get_device_size(devname))
                 self.data[devname] = device
 
-
     def remove(self, devices):
         misc.wipefs(devices, CRYPT_SIGNATURES)
diff --git a/ssmlib/backends/lvm.py b/ssmlib/backends/lvm.py
index d6e3171..b4b2570 100644
--- a/ssmlib/backends/lvm.py
+++ b/ssmlib/backends/lvm.py
@@ -23,7 +23,7 @@ from ssmlib import misc
 from ssmlib import problem
 from ssmlib.backends import template
 
-__all__ = ["PvsInfo", "VgsInfo", "LvsInfo"]
+__all__ = ["PvsInfo", "VgsInfo", "LvsInfo", "ThinPool"]
 
 try:
     SSM_LVM_DEFAULT_POOL = os.environ['SSM_LVM_DEFAULT_POOL']
@@ -36,24 +36,37 @@ except KeyError:
     DM_DEV_DIR = "/dev"
 MAX_LVS = 999
 
+# TODO: This is ugly and needs to be removed and done properly
+THIN_POOL_DATA = {}
 
 def get_lvm_version():
     try:
         output = misc.run(['lvm', 'version'], can_fail=True)[1]
         output = output.strip().split("\n")
         pattern = re.compile("LVM version:")
+        version = [0, 0, 0]
         for line in output:
             if pattern.match(line.strip()):
                 match = " ".join(line.split())
                 tmp = re.search(r'(?<=LVM version: )\d+\.\d+\.\d+',
                                     match).group(0)
-                version = map(int, tmp.split(".", 3))
+                version = list(map(int, tmp.split(".", 3)))
     except (OSError, AttributeError):
         version = [0, 0, 0]
     return version
 
 LVM_VERSION = get_lvm_version()
 
+def create_thin_volume(parent_pool, thin_pool, virtsize, lvname):
+    pool_volume = parent_pool + '/' + thin_pool
+
+    # Ignore options for non existing thin volumes somehow
+    command = ['lvcreate', '-n', lvname, '-T', pool_volume,
+               '-V', str(virtsize) + 'K']
+    command.insert(0, "lvm")
+    misc.run(command, stdout=True)
+    return "{0}/{1}/{2}".format(DM_DEV_DIR, parent_pool, lvname)
+
 
 class LvmInfo(template.Backend):
 
@@ -78,7 +91,6 @@ class LvmInfo(template.Backend):
              problem.FL_DEFAULT_NO | problem.FL_EXIT_ON_NO | problem.FL_FORCE_YES,
              problem.GeneralError]
 
-
     def run_lvm(self, command, noforce=False):
         if not self.binary:
             self.problem.check(self.problem.TOOL_MISSING, 'lvm')
@@ -141,10 +153,12 @@ class VgsInfo(LvmInfo, template.BackendPool):
     def _data_index(self, row):
         return row['pool_name']
 
-    def _generate_lvname(self, vg):
+    def _generate_lvname(self, lvname, vg):
         for i in range(1, MAX_LVS):
-            name = "lvol{0:0>{align}}".format(i, align=len(str(MAX_LVS)))
+            name = "{0}{1:0>{align}}".format(lvname, i, align=len(str(MAX_LVS)))
             path = "{0}/{1}/{2}".format(DM_DEV_DIR, vg, name)
+            if name in THIN_POOL_DATA:
+                continue
             try:
                 if stat.S_ISBLK(os.stat(path).st_mode):
                     continue
@@ -180,14 +194,22 @@ class VgsInfo(LvmInfo, template.BackendPool):
         options = options or {}
         devices = devs or []
         command = ['lvcreate', vg]
+        virtsize = None
 
-        if name:
+        if 'virtsize' in options:
+            # We're going to create new lv which is going to be thin pool
+            # so name it appropriately
+            lvname = self._generate_lvname(vg + "_thin", vg)
+        elif name:
             lvname = name
         else:
-            lvname = self._generate_lvname(vg)
+            lvname = self._generate_lvname("lvol", vg)
+
+        if 'virtsize' in options:
+            command.extend(['-T'])
 
         if size:
-            command.extend(['-L', size + 'K'])
+            command.extend(['-L', str(size) + 'K'])
         else:
             if len(devices) > 0:
                 tmp = "100%PVS"
@@ -237,7 +259,7 @@ class VgsInfo(LvmInfo, template.BackendPool):
                     if len(devices) % 2 != 0:
                         self.problem.error("Number of devices should be " +
                                            "even in raid 10 setup")
-                    options['stripes'] = str(len(devices)/2)
+                    options['stripes'] = str(len(devices)//2)
                 if not options['stripes']:
                     self.problem.error("Devices or number of " +
                                        "stripes should be defined")
@@ -257,9 +279,20 @@ class VgsInfo(LvmInfo, template.BackendPool):
                 self.problem.not_supported("RAID level {0}".format(options['raid']) +
                                            " with \"lvm\" backend")
 
+        # This should be done only if necessary - for example when the size
+        # was not provided and is used as %PVS, otherwise let lvm decide
+        # which devices to use from the pool.
         command.extend(devices)
         self.run_lvm(command, noforce=True)
-        return "{0}/{1}/{2}".format(DM_DEV_DIR, vg, lvname)
+        path = "{0}/{1}/{2}".format(DM_DEV_DIR, vg, lvname)
+        if 'virtsize' in options:
+            thin_pool = lvname
+            if name:
+                lvname = name
+            else:
+                lvname = self._generate_lvname("tvol", vg)
+            path = create_thin_volume(vg, thin_pool, options['virtsize'], lvname)
+        return path
 
 
 class PvsInfo(LvmInfo, template.BackendDevice):
@@ -299,9 +332,9 @@ class LvsInfo(LvmInfo, template.BackendVolume):
         super(LvsInfo, self).__init__(*args, **kwargs)
         command = ["lvm", "lvs", "--separator", "|", "--noheadings",
                    "--nosuffix", "--units", "k", "-o",
-                   "vg_name,lv_size,stripes,stripesize,segtype,lv_name,origin,lv_attr"]
+                   "vg_name,lv_size,stripes,stripesize,segtype,lv_name,origin,lv_attr,pool_lv"]
         self.attrs = ['pool_name', 'vol_size', 'stripes',
-                      'stripesize', 'type', 'lv_name', 'origin', 'attr']
+                      'stripesize', 'type', 'lv_name', 'origin', 'attr', 'pool_lv']
         self.handle_fs = True
         self.mounts = misc.get_mounts('{0}/mapper'.format(DM_DEV_DIR))
         self._parse_data(command)
@@ -309,9 +342,15 @@ class LvsInfo(LvmInfo, template.BackendVolume):
     def _fill_aditional_info(self, lv):
         lv['dev_name'] = "{0}/{1}/{2}".format(DM_DEV_DIR, lv['pool_name'],
                                               lv['lv_name'])
-        if lv['origin']:
+        if lv['origin'] or \
+           lv['attr'][0] == 't':
             lv['hide'] = True
 
+        # Show thin-pool as a pool name in case of thin volumes
+        if lv['type'] == 'thin':
+            lv['parent_pool'] = lv['pool_name']
+            lv['pool_name'] = lv['pool_lv']
+
         lv['real_dev'] = misc.get_real_device(lv['dev_name'])
 
         sysfile = "/sys/block/{0}/dm/name".format(
@@ -332,15 +371,17 @@ class LvsInfo(LvmInfo, template.BackendVolume):
         self.parse_attr(lv, lv['attr'])
 
     def __getitem__(self, name):
-        if name in self.data.iterkeys():
+        if name in self.data:
             return self.data[name]
+        if DM_DEV_DIR + "/" + name in self.data:
+            return self.data[DM_DEV_DIR + "/" + name]
         device = name
         if not os.path.exists(name):
             device = DM_DEV_DIR + "/" + name
             if not os.path.exists(device):
                 return None
         device = misc.get_real_device(device)
-        if device in self.data.iterkeys():
+        if device in self.data:
             return self.data[device]
         return None
 
@@ -375,14 +416,29 @@ class LvsInfo(LvmInfo, template.BackendVolume):
             command.insert(1, '-r')
         self.run_lvm(command)
 
-    def snapshot(self, lv, destination, name, size, user_set_size):
+    def snapshot(self, lv, destination, name, snap_size=None):
+        vol = self[lv]
+        vol_size = float(vol['vol_size'])
         lv = self._get_dev_name(lv)
+
         if not name:
             now = datetime.datetime.now()
             name = now.strftime("snap%Y%m%dT%H%M%S")
 
-        command = ['lvcreate', '--size', str(size) + 'K', '--snapshot',
-                   '--name', name, lv]
+        if vol['type'] == "thin":
+            if snap_size:
+                self.problem.warn("Setting snapshot size for thin volume is" +
+                                  " not supported")
+                snap_size = None
+        elif not snap_size:
+            # We'll ceate snapshot of the size of 20% of the original volume
+            snap_size = vol_size * 0.20
+
+        if snap_size:
+            command = ['lvcreate', '--size', str(snap_size) + 'K', '--snapshot',
+                       '--name', name, lv]
+        else:
+            command = ['lvcreate', '--snapshot', '--name', name, lv]
 
         self.run_lvm(command)
 
@@ -394,10 +450,10 @@ class SnapInfo(LvmInfo):
         command = ["lvm", "lvs", "--separator", "|", "--noheadings",
                    "--nosuffix", "--units", "k", "-o",
                    "vg_name,lv_size,stripes,stripesize,segtype," +
-                   "lv_name,origin,snap_percent,lv_attr"]
+                   "lv_name,origin,snap_percent,lv_attr,pool_lv"]
         self.attrs = ['pool_name', 'vol_size', 'stripes',
                       'stripesize', 'type', 'lv_name', 'origin',
-                      'snap_size', 'attr']
+                      'snap_size', 'attr', 'pool_lv']
         self.handle_fs = True
         self.mounts = misc.get_mounts('{0}/mapper'.format(DM_DEV_DIR))
         self._parse_data(command)
@@ -416,8 +472,14 @@ class SnapInfo(LvmInfo):
                                                 snap['lv_name'])
         snap['hide'] = False
         snap['snap_path'] = snap['dev_name']
-        size = float(snap['vol_size']) * float(snap['snap_size'])
-        snap['snap_size'] = str(size / 100.00)
+
+        if snap['type'] != "thin":
+            size = float(snap['vol_size']) * float(snap['snap_size'])
+            snap['snap_size'] = str(size / 100.00)
+        else:
+            # Show thin-pool as a pool name in case of thin volumes
+            snap['parent_pool'] = snap['pool_name']
+            snap['pool_name'] = snap['pool_lv']
 
         snap['real_dev'] = misc.get_real_device(snap['dev_name'])
 
@@ -434,7 +496,129 @@ class SnapInfo(LvmInfo):
         except IOError:
             snap['dm_name'] = snap['real_dev']
 
-        if snap['dm_name'] in self.mounts:
-            snap['mount'] = self.mounts[snap['dm_name']]['mp']
+        if snap['real_dev'] in self.mounts:
+            snap['mount'] = self.mounts[snap['real_dev']]['mp']
 
         self.parse_attr(snap, snap['attr'])
+
+
+class ThinPool(LvmInfo, template.BackendPool):
+
+    def __init__(self, *args, **kwargs):
+        super(ThinPool, self).__init__(*args, **kwargs)
+        self.type = 'thin'
+        command = ["lvm", "lvs", "--separator", "|", "--noheadings",
+                   "--nosuffix", "--units", "k", "-o",
+                   "vg_name,lv_size,stripes,stripesize,segtype,lv_name," +
+                   "origin,lv_attr,pv_count,thin_count,data_percent," +
+                   "metadata_percent,snap_percent"]
+        self.attrs = ['parent_pool', 'vol_size', 'stripes',
+                      'stripesize', 'type', 'lv_name', 'origin', 'attr',
+                      'dev_count', 'vol_count', 'data_percent',
+                      'metadata_percent', 'snap_percent']
+        self._parse_data(command)
+        # Uff, so ugly...needs to be changed
+        global THIN_POOL_DATA
+        THIN_POOL_DATA = self.data
+
+    def _fill_aditional_info(self, vg):
+        vg['type'] = 'thin'
+        vg['pool_name'] = os.path.basename(vg['lv_name'])
+        vg['pool_size'] = vg['vol_size']
+        vg['pool_used'] = float(vg['vol_size']) * (float(vg['data_percent'])/100)
+        vg['pool_free'] = float(vg['vol_size']) - vg['pool_used']
+        if vg['attr'][4] == 'a':
+            vg['active'] = True
+        else:
+            vg['active'] = False
+
+
+    def _data_index(self, row):
+        return row['pool_name']
+
+    def _skip_data(self, row):
+        if row['attr'][0] not in ['t', 'T']:
+            return True
+        else:
+            return False
+
+    def _generate_lvname(self, lvname, vg):
+        for i in range(1, MAX_LVS):
+            name = "{0}{1:0>{align}}".format(lvname, i, align=len(str(MAX_LVS)))
+            path = "{0}/{1}/{2}".format(DM_DEV_DIR, vg, name)
+            if name in self.data:
+                continue
+            try:
+                if stat.S_ISBLK(os.stat(path).st_mode):
+                    continue
+            except OSError:
+                pass
+            return name
+        self.problem.error("Can not find proper lvname!")
+
+    def reduce(self, vg, device):
+        msg = "Removing devices from thin pool"
+        self.problem.check(self.problem.NOT_SUPPORTED, msg)
+
+    def new(self, vg, devices):
+        msg = "Creating a new"
+        self.problem.check(self.problem.NOT_SUPPORTED, msg)
+
+    def extend(self, vg, devices):
+        # Add devices to the parent pool first
+        vg = self[vg]
+        pool = vg['parent_pool']
+        if type(devices) is not list:
+            devices = [devices]
+        command = ['vgextend', pool]
+        command.extend(devices)
+        self.run_lvm(command)
+        # Now resize the thin-pool volume
+        lv = vg['parent_pool'] + '/' + vg['lv_name']
+        command = ['lvresize', lv]
+        command.extend(devices)
+        if vg['active'] == False:
+            self.problem.check(self.DEVICE_INACTIVE, lv)
+        self.run_lvm(command)
+
+    def remove(self, vg):
+        vg = self[vg]
+        lvname = vg['parent_pool'] + '/' + vg['lv_name']
+        command = ['lvremove', lvname]
+        self.run_lvm(command)
+
+    def create(self, vg, size=None, name=None, devs=None,
+               options=None):
+        vg = self[vg]
+        if vg['active'] == False:
+            self.problem.check(self.DEVICE_INACTIVE, lv)
+
+        if name:
+            lvname = name
+        else:
+            lvname = self._generate_lvname("tvol", vg['parent_pool'])
+
+        pool_volume = vg['parent_pool'] + '/' + vg['lv_name']
+
+        # Once can specify either --size or --virtual-size argument when
+        # creating thin volume out of thin pool, but not both.
+        if size and 'virtsize' in options:
+            self.problem.error("Either '--size' or '--virtual-size' can be" +
+                               " can be specified for new thin volume size" +
+                               " but not both")
+
+        virtsize = None
+        # Size needs to be specified for the thin volume
+        if 'virtsize' in options:
+            virtsize = options['virtsize']
+        elif size:
+            virtsize = size
+        else:
+            self.problem.error("Size must be specified to create a volume " +
+                               "from a thin pool")
+
+        # Ignore options for non existing thin volumes somehow
+        command = ['lvcreate', '-n', lvname, '-T', pool_volume,
+                   '-V', str(virtsize) + 'K']
+        self.run_lvm(command)
+        return "{0}/{1}/{2}".format(DM_DEV_DIR, vg['parent_pool'], lvname)
diff --git a/ssmlib/backends/md.py b/ssmlib/backends/md.py
index fca2c98..de8d4ef 100644
--- a/ssmlib/backends/md.py
+++ b/ssmlib/backends/md.py
@@ -50,7 +50,7 @@ class MdRaid(template.Backend):
         mdnumber = misc.get_dmnumber("md")
 
         for line in misc.get_partitions():
-            devname = '/dev/' + line[3]
+            devname = line[3]
             devsize = int(line[2])
             if line[0] == mdnumber:
                 self._vol[devname] = self.get_volume_data(devname)
diff --git a/ssmlib/backends/template.py b/ssmlib/backends/template.py
index bf1b6ad..49c3cc0 100644
--- a/ssmlib/backends/template.py
+++ b/ssmlib/backends/template.py
@@ -41,11 +41,11 @@ class Backend(object):
         return repr(self.data)
 
     def __iter__(self):
-        for item in sorted(self.data.iterkeys()):
+        for item in sorted(self.data):
             yield item
 
     def __getitem__(self, key):
-        if key in self.data.iterkeys():
+        if key in self.data:
             return self.data[key]
 
 
diff --git a/ssmlib/main.py b/ssmlib/main.py
index b0f40e8..6d9f9f0 100644
--- a/ssmlib/main.py
+++ b/ssmlib/main.py
@@ -19,6 +19,7 @@ import re
 import os
 import sys
 import stat
+import atexit
 import argparse
 from ssmlib import misc
 from ssmlib import problem
@@ -45,6 +46,13 @@ try:
 except KeyError:
     SSM_NONINTERACTIVE = not os.isatty(sys.stdout.fileno())
 
+if sys.version < '3':
+    def __next__(iter):
+        return iter.next()
+else:
+    def __next__(iter):
+        return next(iter)
+
 
 class Options(object):
     """
@@ -95,6 +103,85 @@ class Struct(object):
     def __init__(self):
         pass
 
+def calculate_size(arg_size, pool):
+
+    if not arg_size:
+        return arg_size
+    # Size argument specified in kilobytes, just return it
+    if arg_size[1] == 'K':
+         return float(arg_size[0])
+
+    if not pool or not pool.exists():
+        # There is no pooling support, we do not support specifying
+        # percentage in this case
+        raise PR.error("There is no pooling support for this volume. " +
+                       "Size needs to be specified as a real size")
+    else:
+        pool_free = float(pool['pool_free'])
+        pool_used = float(pool['pool_used'])
+        pool_size = float(pool['pool_size'])
+
+    if arg_size[1] == 'FREE':
+        base_size = pool_free
+    elif arg_size[1] == 'USED':
+        base_size = pool_used
+    elif arg_size[1] == '':
+        base_size = pool_size
+
+    mult = float(arg_size[0]) / 100.00
+
+    return base_size *  mult
+
+def calculate_resize_size(arg_size, volume, pool):
+    vol_size = float(volume['vol_size'])
+
+    # If no size specified we're going to resize to the full
+    # volume size
+    if not arg_size:
+        return vol_size
+
+    # Size argument specified in kilobytes, so simply calculate the size
+    # and return
+    if arg_size[1] == 'K':
+        base_size = float(arg_size[0])
+        if arg_size[0][0] in ['+', '-']:
+            new_size = vol_size + base_size
+        else:
+            new_size = base_size
+        return new_size
+
+    if not pool and arg_size[1] in ['']:
+        # There is no pooling support, but we're not going to need any
+        # pool related information. Everything is volume centric in this
+        # case
+        pool_free = 0
+        pool_used = 0
+    elif not pool and arg_size[1] not in ['']:
+        # FREE and USED is based on pool and since we do not have pooling
+        # support for this volume, we can't proceed
+        raise PR.error("There is no pooling support for volume " +
+                       "\'{0}\'. Size needs to be ".format(volume['dev_name']) +
+                       "specified as a real size, or plain percentage")
+    else:
+        pool_free = float(pool['pool_free'])
+        pool_used = float(pool['pool_used'])
+
+    if arg_size[1] == 'FREE':
+        base_size = pool_free
+    elif arg_size[1] == 'USED':
+        base_size = pool_used
+    elif arg_size[1] == '':
+        base_size = vol_size
+
+    mult = float(arg_size[0]) / 100.00
+    base_size *= mult
+    if arg_size[0][0] in ['+', '-']:
+        new_size = vol_size + base_size
+    else:
+        new_size = base_size
+
+    return new_size
+
 
 class StoreAll(argparse._StoreAction):
     """
@@ -151,7 +238,11 @@ class FsInfo(object):
         fstype = self.fstype
         if re.match("ext[2|3|4]", self.fstype):
             fstype = "extN"
-        func = getattr(self, "{0}_{1}".format(fstype, func))
+        try:
+            func = getattr(self, "{0}_{1}".format(fstype, func))
+        except AttributeError:
+            msg = "{0} file system is not yet supported.".format(fstype)
+            raise problem.NotSupported(msg)
         return func(*args, **kwargs)
 
     def fsck(self):
@@ -182,9 +273,9 @@ class FsInfo(object):
         bcount = int(self.fs_info['Block count'])
         rbcount = int(self.fs_info['Reserved block count'])
         fbcount = int(self.fs_info['Free blocks'])
-        self.data['fs_size'] = bcount * bsize / 1024
-        self.data['fs_free'] = (fbcount - rbcount) * bsize / 1024
-        self.data['fs_used'] = (bcount - fbcount) * bsize / 1024
+        self.data['fs_size'] = bcount * bsize // 1024
+        self.data['fs_free'] = (fbcount - rbcount) * bsize // 1024
+        self.data['fs_used'] = (bcount - fbcount) * bsize // 1024
 
     def extN_fsck(self):
         command = ['fsck.{0}'.format(self.fstype), '-f', '-n']
@@ -201,6 +292,7 @@ class FsInfo(object):
 
     def extN_resize(self, new_size=None):
         command = ['resize2fs', self.device]
+        new_size = int(new_size)
         if not misc.check_binary(command[0]):
             PR.warn("\'{0}\' tool does not exist. ".format(command[0]) +
                     "File system will not be resized")
@@ -210,20 +302,20 @@ class FsInfo(object):
         if self.options.verbose:
             command.insert(1, "-p")
         if new_size:
-            command.append(new_size)
+            command.append(str(new_size) + 'K')
         # Ext3/4 can resize offline in both directions, but It can not shrink
         # the file system while online. In addition ext2 can only resize
         # offline.
         if self.mounted and (self.fstype == "ext2" or
            new_size < self.data['fs_size']):
-            raise Exception(
-                "{0} is mounted on {1}".format(self.device, self.mounted) +
+            raise problem.FsMounted(
+                "{0} is mounted on {1}.".format(self.device, self.mounted) +
                 " In this case, mounted file system can not be resized.")
         ret = self.fsck()
         if ret:
-            raise Exception("File system on {0} is not ".format(self.device) +
-                            "clean, I will not attempt to resize it. Please," +
-                            "fix the problem first.")
+            raise PR.error("File system on {0} is not ".format(self.device) +
+                           "clean, I will not attempt to resize it. Please," +
+                           "fix the problem first")
         return misc.run(command, stdout=True)[0]
 
     def xfs_get_info(self, dev):
@@ -244,9 +336,9 @@ class FsInfo(object):
         agcount = int(self.fs_info['agcount'])
         fbcount = int(self.fs_info['fdblocks'])
         fbcount -= 4 + (4 + agcount)
-        self.data['fs_size'] = bcount * bsize / 1024
-        self.data['fs_free'] = fbcount * bsize / 1024
-        self.data['fs_used'] = (bcount - fbcount) * bsize / 1024
+        self.data['fs_size'] = bcount * bsize // 1024
+        self.data['fs_free'] = fbcount * bsize // 1024
+        self.data['fs_used'] = (bcount - fbcount) * bsize // 1024
 
     def xfs_fsck(self):
         command = ['xfs_repair', '-n']
@@ -260,6 +352,7 @@ class FsInfo(object):
         return misc.run(command, stdout=True, can_fail=True)[0]
 
     def xfs_resize(self, new_size=None):
+        new_size = int(new_size)
         command = ['xfs_growfs', self.device]
         if not misc.check_binary(command[0]):
             PR.warn("\'{0}\' tool does not exist. ".format(command[0]) +
@@ -268,10 +361,10 @@ class FsInfo(object):
         if new_size:
             command.insert(1, ['-D', new_size + 'K'])
         if not self.mounted:
-            raise Exception("Xfs file system on {0}".format(self.device) +
-                            " has to be mounted to perform an resize.")
+            raise PR.error("Xfs file system on {0}".format(self.device) +
+                           " has to be mounted to perform an resize")
         elif new_size and new_size < self.data['fs_size']:
-            raise Exception("Xfs file system can not shrink.")
+            raise PR.error("Xfs file system can not shrink")
         else:
             misc.run(command, stdout=True)
 
@@ -305,7 +398,7 @@ class DeviceInfo(object):
         for items in misc.get_partitions():
             devices = dict(zip(self.attrs, items))
             devices['vol_size'] = devices['dev_size']
-            devices['dev_name'] = "/dev/" + devices['dev_name']
+            devices['dev_name'] = devices['dev_name']
             if devices['major'] in hide_dmnumbers:
                 devices['hide'] = True
             if devices['dev_name'] in self.data:
@@ -322,7 +415,7 @@ class DeviceInfo(object):
             if item[0] in self.data:
                 self.data[item[0]]['mount'] = "SWAP"
 
-        for i, dev in enumerate(self.data.itervalues()):
+        for i, dev in enumerate(self.data.values()):
             if 'minor' in dev and dev['minor'] != '0':
                 continue
             part = 0
@@ -346,18 +439,18 @@ class DeviceInfo(object):
     def remove(self, device):
         PR.error("It is not clear what do you want " +
                  "to achieve by removing " +
-                 "{0}!".format(device))
+                 "{0}".format(device))
 
     def set_globals(self, options):
         self.options = options
 
     def __iter__(self):
-        for item in sorted(self.data.iterkeys()):
+        for item in sorted(self.data):
             yield item
 
     def __getitem__(self, name):
         device = misc.get_real_device(name)
-        if device in self.data.iterkeys():
+        if device in self.data:
             return self.data[device]
         return None
 
@@ -450,7 +543,7 @@ class Storage(object):
         self.set_globals(options)
 
     def __iter__(self):
-        for source in self._data.itervalues():
+        for source in self._data.values():
             for item in source:
                 yield Item(source, item)
 
@@ -461,7 +554,7 @@ class Storage(object):
             return False
 
     def __getitem__(self, name):
-        for source in self._data.itervalues():
+        for source in self._data.values():
             item = source[name]
             if item:
                 return Item(source, name)
@@ -480,7 +573,7 @@ class Storage(object):
         if not SSM_PREFIX_FILTER:
             return
         reg = re.compile("^{0}".format(SSM_PREFIX_FILTER))
-        for source in self._data.itervalues():
+        for source in self._data.values():
             for item in source:
                 if reg.search(os.path.basename(item)):
                     continue
@@ -499,7 +592,7 @@ class Storage(object):
         self.options = options
         if self._data is None:
             return
-        for source in self._data.itervalues():
+        for source in self._data.values():
             source.options = options
 
     def filesystems(self):
@@ -613,27 +706,27 @@ class Storage(object):
                     fmt += "{{{0}:{1}}}  ".format(pos, alignment[i])
             pos += 1
 
-        print "-" * width
-        print fmt.format(*tuple(header))
-        print "-" * width
+        print("-" * width)
+        print(fmt.format(*tuple(header)))
+        print("-" * width)
         # Now print each line of the table. When the first attribute of the
         # line is longer than it should be we know that we have to wrap the
         # line.
         for i, line in enumerate(lines):
             line = misc.compress(line, columns)
-            tmp1 = line.next()
+            tmp1 = __next__(line)
             if len(tmp1) > alignment[0]:
-                print tmp1
-                print fmt.format('', *line)
+                print(tmp1)
+                print(fmt.format('', *line))
             else:
-                print fmt.format(tmp1, *line)
-        print "-" * width
+                print(fmt.format(tmp1, *line))
+        print("-" * width)
 
 
 class Pool(Storage):
     """
     Store Pools from all the backends. When new backend is added into the ssm
-    it should be registered withing this class with appropriate name.
+    it should be registered within this class with appropriate name.
     """
 
     def __init__(self, *args, **kwargs):
@@ -641,33 +734,39 @@ class Pool(Storage):
 
         try:
             self._data['lvm'] = lvm.VgsInfo(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about LVM pools")
         try:
+            self._data['thin'] = lvm.ThinPool(options=self.options)
+        except RuntimeError as err:
+            PR.warn(err)
+            PR.warn("Can not get information about thin pools")
+        try:
             self._data['btrfs'] = btrfs.BtrfsPool(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about btrfs pools")
         try:
             self._data['crypt'] = crypt.DmCryptPool(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about crypt pools")
 
         backend = self.get_backend(SSM_DEFAULT_BACKEND)
         self.default = Item(backend, backend.default_pool_name)
-        self.header = ['Pool', 'Type', 'Devices', 'Free', 'Used', 'Total']
+        self.header = ['Pool', 'Type', 'Devices', 'Free', 'Used',
+                       'Total', 'Parent']
         self.attrs = ['pool_name', 'type', 'dev_count', 'pool_free',
-                      'pool_used', 'pool_size']
-        self.types = [str, str, str, float, float, float]
+                      'pool_used', 'pool_size', 'parent_pool']
+        self.types = [str, str, str, float, float, float, str]
         self._apply_prefix_filter()
 
 
 class Devices(Storage):
     """
     Store Devices from all the backends. When new backend is added into the ssm
-    it should be registered withing this class with appropriate name.
+    it should be registered within this class with appropriate name.
 
     If the backend only have new information about the device which is already
     discovered by the DeviceInfo() class then it should just add the
@@ -680,35 +779,35 @@ class Devices(Storage):
 
         try:
             my_lvm = lvm.PvsInfo(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about LVM physical volumes")
         try:
             my_btrfs = btrfs.BtrfsDev(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about btrfs devices")
             my_btrfs = Struct()
             my_btrfs.data = {}
         try:
             my_md = md.MdRaidDevice(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about MD devices")
             my_md = Struct()
             my_md.data = {}
         try:
             my_crypt = crypt.DmCryptDevice(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about crypt devices")
             my_crypt = Struct()
             my_crypt.data = {}
 
-        self._data['dev'] = DeviceInfo(data=dict(my_lvm.data.items() +
-                                                 my_btrfs.data.items() +
-                                                 my_md.data.items() +
-                                                 my_crypt.data.items()),
+        self._data['dev'] = DeviceInfo(data=dict(list(my_lvm.data.items()) +
+                                                 list(my_btrfs.data.items()) +
+                                                 list(my_md.data.items()) +
+                                                 list(my_crypt.data.items())),
                                        options=self.options)
         self.header = ['Device', 'Free', 'Used',
                        'Total', 'Pool', 'Mount point']
@@ -729,22 +828,22 @@ class Volumes(Storage):
 
         try:
             self._data['lvm'] = lvm.LvsInfo(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about LVM volumes")
         try:
             self._data['crypt'] = crypt.DmCryptVolume(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about crypt volumes")
         try:
             self._data['btrfs'] = btrfs.BtrfsVolume(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about btrfs volumes")
         try:
             self._data['md'] = md.MdRaidVolume(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about md raid volumes")
 
@@ -768,16 +867,16 @@ class Snapshots(Storage):
 
         try:
             self._data['lvm'] = lvm.SnapInfo(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about LVM snapshots")
         try:
             self._data['btrfs'] = btrfs.BtrfsSnap(options=self.options)
-        except RuntimeError, err:
+        except RuntimeError as err:
             PR.warn(err)
             PR.warn("Can not get information about btrfs snapshots")
 
-        self.header = ['Snapshot', 'Origin', 'Pool', 'Volume size', 'Size',
+        self.header = ['Snapshot', 'Origin', 'Pool', 'Volume size', 'Used',
                        'Type', 'Mount point']
         self.attrs = ['dev_name', 'origin', 'pool_name', 'vol_size',
                       'snap_size', 'type', 'mount']
@@ -903,7 +1002,7 @@ class StorageHandle(object):
             # Does backend support check ?
             try:
                 if getattr(dev, "check"):
-                    print "Checking volume \'{0}\'.".format(dev['real_dev'])
+                    print("Checking volume \'{0}\'.".format(dev['real_dev']))
                     ret = dev.check()
                     checked += 1
                     err += ret
@@ -915,8 +1014,8 @@ class StorageHandle(object):
             # Do we have a file system to check ?
             if 'fs_info' in dev:
                 fs = dev['fs_info']
-                print "Checking {0} file system on \'{1}\'.".format(fs.fstype,
-                                                                    fs.device)
+                print("Checking {0} file system on \'{1}\'.".format(fs.fstype,
+                                                                    fs.device))
                 ret = fs.fsck()
                 checked += 1
                 err += ret
@@ -958,7 +1057,7 @@ class StorageHandle(object):
                         args.device.append(dev)
                         changed = True
                     elif new_size is None:
-                        PR.error("Device \'{0}\' can not be used!".format(dev))
+                        PR.error("Device \'{0}\' can not be used".format(dev))
                     else:
                         devices.remove(dev)
                         continue
@@ -970,7 +1069,7 @@ class StorageHandle(object):
                 # would be different than what user expected, so we should fail
                 # right away.
                 elif new_size is None:
-                    PR.error("Device \'{0}\' can not be used!".format(dev))
+                    PR.error("Device \'{0}\' can not be used".format(dev))
                 else:
                     devices.remove(dev)
                     continue
@@ -988,7 +1087,10 @@ class StorageHandle(object):
                         continue
                 signature = misc.get_fs_type(dev)
                 if signature and \
-                   not PR.check(PR.EXISTING_FILESYSTEM, [signature, dev]):
+                   PR.check(PR.EXISTING_FILESYSTEM, [signature, dev]):
+                    misc.wipefs(dev, signature)
+                    args.device.append(dev)
+                elif signature:
                     devices.remove(dev)
                     continue
                 else:
@@ -1019,18 +1121,21 @@ class StorageHandle(object):
         args.pool = self.pool[args.volume['pool_name']]
         vol_size = float(args.volume['vol_size'])
 
-        if args.pool.type == 'btrfs':
+        if args.pool != None and args.pool.type == 'btrfs':
             msg = "Resizing btrfs volume is not supported"
             raise problem.NotSupported(msg)
 
-        if not args.size:
-            new_size = vol_size
-        elif args.size[0] == '+':
-            new_size = vol_size + float(args.size[1:])
-        elif args.size[0] == '-':
-            new_size = vol_size + float(args.size)
+        # Backend might not support pooling
+        if args.pool is None:
+            pool_free = 0.0
+            pool_name = "none"
         else:
-            new_size = float(args.size)
+            pool_free = float(args.pool['pool_free'])
+            pool_name = args.pool.name
+
+        # Calculate the size from the size argument
+        new_size = calculate_resize_size(args.size, args.volume, args.pool)
+
         size_change = new_size - vol_size
 
         fs = True if 'fs_info' in args.volume else False
@@ -1049,14 +1154,6 @@ class StorageHandle(object):
                 PR.check(PR.RESIZE_ALREADY_MATCH, [args.volume.name, new_size])
             return
 
-        # Backend might not support pooling
-        if args.pool is None:
-            pool_free = 0.0
-            pool_name = "none"
-        else:
-            pool_free = float(args.pool['pool_free'])
-            pool_name = args.pool.name
-
         # No need to do anything with provided devices since
         # we do have enough space to cover the resize
         if (pool_free < size_change):
@@ -1066,7 +1163,10 @@ class StorageHandle(object):
         else:
             have_size = pool_free
 
-        if have_size < size_change:
+        if args.volume['type'] == 'thin':
+            # No reason to check anything here size is not an concern
+            pass
+        elif have_size < size_change:
             PR.check(PR.RESIZE_NOT_ENOUGH_SPACE,
                      [pool_name, args.volume.name, new_size])
         elif len(args.device) > 0 and size_change > pool_free:
@@ -1085,6 +1185,9 @@ class StorageHandle(object):
         provided as arguments. If the device is not in the selected pool, then
         add() is called on the pool prior to create().
         """
+        if args.mnt_options and not self._mpoint:
+            PR.warn("Mount options are set, but no mount point was " +
+                    "provided. Device will not be mounted")
 
         lvname = self.create_volume(args)
 
@@ -1102,13 +1205,11 @@ class StorageHandle(object):
             if self._create_fs(args.fstype, lvname) != 0:
                 self._mpoint = None
         if self._mpoint:
+            create_directory(self._mpoint)
             self.reinit_vol()
-            self._do_mount(self.vol[lvname])
+            self._do_mount(self.vol[lvname], args.mnt_options)
 
     def create_volume(self, args):
-        # Get the size in kilobytes
-#        if args.size:
-#            args.size = misc.get_real_size(args.size)
 
         if self._mpoint and not (args.fstype or args.pool.type == 'btrfs'):
             if PR.check(PR.CREATE_MOUNT_NOFS, self._mpoint):
@@ -1124,8 +1225,16 @@ class StorageHandle(object):
         if len(devices) > 0:
             pool_free = None
 
+        if args.size and args.size[1] == 'K':
+            # If the exact size was provided than just use that
+             vol_size = float(args.size[0])
+        else:
+            # Otherwise we have to wait after the pool is created, or
+            # devices are added into a existing one
+            vol_size = None
+
         have_size, devices = self._filter_device_list(args, pool_free,
-                                                      args.size)
+                                                      vol_size)
 
         # When the pool does not exist and there is no device usable
         # for creating the new pool, then there is no point of trying to
@@ -1136,10 +1245,12 @@ class StorageHandle(object):
         # Currently we do not allow setting subvolume size with btrfs. This
         # should change in the future (quotas maybe) so the check should
         # be removed or pushed to the backend itself.
-        if args.size and have_size < float(args.size) and \
-           not (args.pool.exists() and args.pool.type == 'btrfs'):
+        if vol_size and have_size < float(vol_size) and \
+           not (args.pool.exists() and args.pool.type == 'btrfs') and \
+           args.pool.type != 'thin':
             if PR.check(PR.CREATE_NOT_ENOUGH_SPACE,
                         [have_size, args.pool.name]):
+                vol_size = None
                 args.size = None
 
         if have_size == 0:
@@ -1159,7 +1270,7 @@ class StorageHandle(object):
                          "({0})".format(tmp))
 
         if args.raid:
-            # In raid we might has a requirement on a number of devices
+            # In raid we might have a requirement on a number of devices
             # available as well as different requirements on the size
             # available. We do not do any complicated math to figure out
             # whether we really do have enough space on the devices which
@@ -1183,10 +1294,12 @@ class StorageHandle(object):
         # want to call add since it would create it. Note that when
         # btrfs pool is created the new btrfs volume is created as well
         # because it is actually the same thing
+        pool_changed = False
         if len(args.device) > 0 and \
            not (not args.pool.exists() and args.pool.type == 'btrfs'):
             try:
                 self.add(args, True)
+                pool_changed = True
             except problem.NotSupported:
                 # Some backends might not support pooling at all.
                 pass
@@ -1198,9 +1311,22 @@ class StorageHandle(object):
             options['raid'] = args.raid
             options['stripesize'] = args.stripesize
             options['stripes'] = args.stripes
+        if args.virtual_size:
+            options['virtsize'] = calculate_size(args.virtual_size, None)
+
+        # Everything is sorted out, now we can safely calculate
+        # the size of the volume, but only is size was specified
+        # but we yet do not have vol_size calculated
+        if args.size and not vol_size:
+            # Pool has been changed so reinitialize it so we can
+            # calculate the size properly
+            if pool_changed:
+                self.reinit_pool()
+                args.pool = self.pool[args.pool.name]
+            vol_size = calculate_size(args.size, args.pool)
 
         lvname = args.pool.create(devs=devices,
-                                  size=args.size,
+                                  size=vol_size,
                                   options=options,
                                   name=args.name)
         return lvname
@@ -1258,8 +1384,10 @@ class StorageHandle(object):
                     else:
                         signature = misc.get_fs_type(dev)
                         if signature and \
-                           not PR.check(PR.EXISTING_FILESYSTEM,
+                           PR.check(PR.EXISTING_FILESYSTEM,
                                         [signature, dev]):
+                            misc.wipefs(dev, signature)
+                        elif signature:
                             args.device.remove(dev)
                             continue
 
@@ -1290,7 +1418,7 @@ class StorageHandle(object):
                     PR.info("Unable to remove '{0}'".format(pool['pool_name']))
                     ret = False
             if removed == 0:
-                PR.error("Nothing was removed!")
+                PR.error("Nothing was removed")
             return ret
         if len(args.items) == 0:
             err = "too few arguments"
@@ -1306,7 +1434,7 @@ class StorageHandle(object):
 
                 item.remove()
                 removed += 1
-            except (RuntimeError, problem.SsmError), ex:
+            except (RuntimeError, problem.SsmError) as ex:
                 PR.info("Unable to remove '{0}'".format(item.name))
                 ret = False
         if removed == 0:
@@ -1318,31 +1446,26 @@ class StorageHandle(object):
         Create a new snapshot of the volume.
         """
         pool = self.pool[args.volume['pool_name']]
-        vol_size = float(args.volume['vol_size'])
         pool_free = float(pool['pool_free'])
 
-        if not args.size:
-        # We'll ceate snapshot of the size of 20% of the original volume
-            snap_size = vol_size * 0.20
-            user_set_size = False
-        else:
-            snap_size = float(args.size)
-            #snap_size = float(misc.get_real_size(args.size))
+        snap_size = None
+        if args.size:
+            snap_size = calculate_resize_size(args.size, args.volume, pool)
+            if pool_free < snap_size:
+                snap_size = pool_free
             user_set_size = True
 
-        if pool_free < snap_size:
-            snap_size = pool_free
-
-        if snap_size <= 0 and pool.type != 'btrfs':
+        if snap_size and snap_size <= 0:
             PR.error("Not enough space ({0} KB) to".format(pool_free) +
                      "to create snapshot")
 
-        args.volume.snapshot(args.dest, args.name, snap_size, user_set_size)
+        args.volume.snapshot(args.dest, args.name, snap_size)
 
     def mount(self, args):
         """
         Mount a volume at given directory.
         """
+        create_directory(args.directory)
         vol = self.vol[args.volume]
         try:
             if vol:
@@ -1407,8 +1530,8 @@ class StorageHandle(object):
             try:
                 mode = os.stat(path).st_mode
             except OSError:
-                err = "'{0}' does not exist.".format(path)
-                raise argparse.ArgumentTypeError(err)
+                self._mpoint = path
+                return
             if stat.S_ISDIR(mode):
                 self._mpoint = path
                 return
@@ -1429,13 +1552,10 @@ class StorageHandle(object):
             pool = self.pool.default
         return pool
 
-    def is_volume(self, string):
+    def can_resize(self, string):
         vol = self.vol[string]
         if vol:
             return vol
-        dev = self.dev[string]
-        if dev and 'fs_info' in dev:
-            return dev
         err = "'{0}' is not a valid volume to resize".format(string)
         raise argparse.ArgumentTypeError(err)
 
@@ -1490,9 +1610,30 @@ class StorageHandle(object):
         err = "'{0}' is not valid pool nor volume".format(string)
         raise argparse.ArgumentTypeError(err)
 
+
 def valid_size(size):
     """ Validate that the 'size' is usable size argument. This is almost the
     same as valid_resize_size() except we do not allow '+' and '-' signs
+
+    >>> valid_size("3.14")
+    ('3.14', 'K')
+    >>> valid_size("+3.14k")
+    Traceback (most recent call last):
+    ...
+    ArgumentTypeError: '+3.14k' is not valid size.
+    >>> valid_size("-3.14k")
+    Traceback (most recent call last):
+    ...
+    ArgumentTypeError: '-3.14k' is not valid size.
+    >>> valid_size("3.14k")
+    ('3.14', 'K')
+    >>> valid_size("3.14G")
+    ('3292528.64', 'K')
+    >>> valid_size("G")
+    Traceback (most recent call last):
+    ...
+    ArgumentTypeError: 'G' is not valid number for the resize.
+
     """
 
     err = "'{0}' is not valid size.".format(size)
@@ -1502,9 +1643,63 @@ def valid_size(size):
         ret = misc.get_real_size(size)
         if float(ret) < 0:
             raise argparse.ArgumentTypeError(err)
+        return (ret, 'K')
     except:
         raise argparse.ArgumentTypeError(err)
-    return ret
+
+def valid_create_size(size):
+    """ Validate that the 'size' is usable size argument. This is almost the
+    same as valid_resize_size() except we do not allow '+' and '-' signs
+
+    >>> valid_create_size("3.14")
+    ('3.14', 'K')
+    >>> valid_create_size("+3.14k")
+    Traceback (most recent call last):
+    ...
+    ArgumentTypeError: '+3.14k' is not valid size.
+    >>> valid_create_size("-3.14k")
+    Traceback (most recent call last):
+    ...
+    ArgumentTypeError: '-3.14k' is not valid size.
+    >>> valid_create_size("3.14k")
+    ('3.14', 'K')
+    >>> valid_create_size("3.14G")
+    ('3292528.64', 'K')
+    >>> valid_create_size("55%FREE")
+    ('55', 'FREE')
+    >>> valid_create_size("+55%FREE")
+    Traceback (most recent call last):
+    ...
+    ArgumentTypeError: '+55%FREE' is not valid size.
+    >>> valid_create_size("55%")
+    ('55', '')
+    >>> valid_create_size("-55%")
+    Traceback (most recent call last):
+    ...
+    ArgumentTypeError: '-55%FREE' is not valid size.
+    >>> valid_create_size("G")
+    Traceback (most recent call last):
+    ...
+    ArgumentTypeError: 'G' is not valid number for the resize.
+
+    """
+
+    err = "'{0}' is not valid size.".format(size)
+    if len(size) and size[0] in ['+', '-']:
+        raise argparse.ArgumentTypeError(err)
+    try:
+        ret = misc.get_real_size(size)
+        if float(ret) < 0:
+            raise argparse.ArgumentTypeError(err)
+        return (ret, 'K')
+    except:
+        try:
+            ret =  misc.get_perc_size_argument(size)
+            if float(ret[0]) < 0:
+                raise argparse.ArgumentTypeError(err)
+        except:
+            raise argparse.ArgumentTypeError(err)
+        return ret
 
 def valid_resize_size(size):
     """
@@ -1514,44 +1709,61 @@ def valid_resize_size(size):
     kilobytes. Is no unit is specified, default is kilobytes.
 
     >>> valid_resize_size("3.14")
-    '3.14'
+    ('3.14', 'K')
     >>> valid_resize_size("+3.14")
-    '+3.14'
+    ('+3.14', 'K')
     >>> valid_resize_size("-3.14")
-    '-3.14'
+    ('-3.14', 'K')
     >>> valid_resize_size("3.14k")
-    '3.14'
+    ('3.14', 'K')
     >>> valid_resize_size("+3.14K")
-    '+3.14'
+    ('+3.14', 'K')
     >>> valid_resize_size("-3.14k")
-    '-3.14'
+    ('-3.14', 'K')
     >>> valid_resize_size("3.14G")
-    '3292528.64'
+    ('3292528.64', 'K')
     >>> valid_resize_size("+3.14g")
-    '+3292528.64'
+    ('+3292528.64', 'K')
     >>> valid_resize_size("-3.14G")
-    '-3292528.64'
+    ('-3292528.64', 'K')
+    >>> valid_resize_size("55%FREE")
+    ('55', 'FREE')
+    >>> valid_resize_size("-55%USED")
+    ('-55', 'USED')
+    >>> valid_resize_size("+55%USED")
+    ('+55', 'USED')
+    >>> valid_resize_size("55%")
+    ('55', '')
+    >>> valid_resize_size("-55%")
+    ('-55', '')
+    >>> valid_resize_size("+55%")
+    ('+55', '')
     >>> valid_resize_size("G")
     Traceback (most recent call last):
     ...
     ArgumentTypeError: 'G' is not valid number for the resize.
     """
     try:
-        return misc.get_real_size(size)
+        return (misc.get_real_size(size), 'K')
     except Exception:
-        err = "'{0}' is not valid number for the resize.".format(size)
-        raise argparse.ArgumentTypeError(err)
+        try:
+            return misc.get_perc_size_argument(size)
+        except Exception:
+            err = "'{0}' is not valid number for the resize.".format(size)
+            raise argparse.ArgumentTypeError(err)
 
 
 def is_directory(string):
+    """
+    Check whether the directory exists, or could be created.
+    """
     if string is None:
         err = "Directory name not defined."
         raise argparse.ArgumentTypeError(err)
     try:
-        mode = os.stat(string).st_mode
+        mode = os.lstat(string).st_mode
     except OSError:
-        err = "'{0}' does not exist.".format(string)
-        raise argparse.ArgumentTypeError(err)
+        return string
     if stat.S_ISDIR(mode):
         return string
     else:
@@ -1559,6 +1771,19 @@ def is_directory(string):
         raise argparse.ArgumentTypeError(err)
 
 
+def create_directory(string):
+    # Create directory if it does not exist, the rest of the check
+    # is already done in is_directory
+    if os.path.isdir(string):
+        return
+    if not PR.check(PR.CREATE_DIRECTORY, string):
+        PR.error("Directory '{0}' does not exist".format(string))
+    try:
+        os.mkdir(string)
+    except OSError:
+        PR.error("Directory '{0}' can\'t be created".format(string))
+
+
 def is_supported_fs(fs):
     if fs in SUPPORTED_FS:
         return fs
@@ -1575,7 +1800,8 @@ class SsmParser(object):
     def __init__(self, storage, prog=None):
         self.storage = storage
         self.parser = self._get_parser_global(prog)
-        self.subcommands = self.parser.add_subparsers(title="Commands")
+        self.subcommands = self.parser.add_subparsers(title="Commands", dest="too few arguments")
+        self.subcommands.required = True
         self.parser_check = self._get_parser_check()
         self.parser_resize = self._get_parser_resize()
         self.parser_create = self._get_parser_create()
@@ -1619,7 +1845,7 @@ class SsmParser(object):
                      Note that with this option ssm will not perform all the
                      check as some of them are done by the backends
                      themselves. This option is mainly used for debugging
-                     purposes.''',
+                     purposes, but still requires root privileges.''',
                 action="store_true")
         return parser
 
@@ -1642,7 +1868,7 @@ class SsmParser(object):
         parser_resize = self.subcommands.add_parser("resize",
                 help="Change or set the volume and file system size.")
         parser_resize.add_argument("volume", help="Volume to resize.",
-                type=self.storage.is_volume)
+                type=self.storage.can_resize)
         parser_resize.add_argument('-s', '--size',
                 help='''New size of the volume. With the + or - sign the
                      value is added to or subtracted from the actual size of
@@ -1650,7 +1876,11 @@ class SsmParser(object):
                      new volume size. A size suffix of [k|K] for kilobytes,
                      [m|M] for megabytes, [g|G] for gigabytes, [t|T] for
                      terabytes or [p|P] for petabytes is optional. If no unit
-                     is provided the default is kilobytes.''',
+                     is provided the default is kilobytes. Additionally the
+                     new size can be specified as a percentage of the original
+                     volume size ([+][-]50%%), as a percentage of free pool
+                     space ([+][-]50%%FREE), or as a percentage of used pool
+                     space ([+][-]50%%USED).''',
                 type=valid_resize_size)
         parser_resize.add_argument("device", nargs='*',
                 help='''Devices to use for extending the volume. If the
@@ -1668,12 +1898,16 @@ class SsmParser(object):
         parser_create = self.subcommands.add_parser("create",
                 help="Create a new volume with defined parameters.")
         parser_create.add_argument('-s', '--size',
-                help='''Gives the size to allocate for the new logical volume
+                help='''Gives the size to allocate for the new logical volume.
                      A size suffix K|k, M|m, G|g, T|t, P|p, E|e can be used
                      to define 'power of two' units. If no unit is provided, it
-                     defaults to kilobytes. This is optional if if
-                     not given maximum possible size will be used.''',
-                type=valid_size)
+                     defaults to kilobytes. This is optional and if
+                     not given, maximum possible size will be used. Additionally
+                     the new size can be specified as a percentage of the
+                     total pool size (50%%), as a percentage of free pool
+                     space (50%%FREE), or as a percentage of used pool space
+                     (50%%USED).''',
+                type=valid_create_size)
         parser_create.add_argument('-n', '--name',
                 help='''The name for the new logical volume. This is optional
                      and if omitted, name will be generated by the
@@ -1713,6 +1947,16 @@ class SsmParser(object):
                 choices=crypt.SUPPORTED_CRYPT, const=True,
                 help='''Create encrpted volume. Extension to use can be
                      specified.''')
+        parser_create.add_argument('-o', '--mnt-options',
+                help='''Mount options are specified with a -o flag followed
+                     by a comma separated string of options. This option is
+                     equivalent to the -o mount(8) option.''')
+        parser_create.add_argument('-v', '--virtual-size',
+                help='''Gives the virtual size for the new thinly provisioned
+                     volume. A size suffix K|k, M|m, G|g, T|t, P|p, E|e can be
+                     used to define 'power of two' units. If no unit is
+                     provided, it defaults to kilobytes.''',
+                type=valid_size)
         parser_create.add_argument('device', nargs='*',
                 help='''Devices to use for creating the volume. If the device
                      is not in any pool, it is added into the pool prior the
@@ -1775,12 +2019,16 @@ class SsmParser(object):
         parser_snapshot = self.subcommands.add_parser("snapshot",
                 help='''Take a snapshot of the existing volume.''')
         parser_snapshot.add_argument('-s', '--size',
-                help='''Gives the size to allocate for the new snapshot volume
+                help='''Gives the size to allocate for the new snapshot volume.
                      A size suffix K|k, M|m, G|g, T|t, P|p, E|e can be used
                      to define 'power of two' units. If no unit is provided, it
-                     defaults to kilobytes. This is option and if not give,
-                     the size will be determined automatically.''',
-                type=valid_size)
+                     defaults to kilobytes. This is optional and if not given,
+                     the size will be determined automatically. Additionally the
+                     new size can be specified as a percentage of the original
+                     volume size (50%%), as a percentage of free pool space
+                     (50%%FREE), or as a percentage of used pool space
+                     (50%%USED).''',
+                type=valid_create_size)
         group = parser_snapshot.add_mutually_exclusive_group()
         group.add_argument('-d', '--dest',
                 help='''Destination of the snapshot specified with absolute
@@ -1838,6 +2086,13 @@ def main(args=None):
                 err = "You can not specify --stripes without specifying" + \
                       " RAID level!"
                 ssm_parser.parser_create.error(err)
+        # This should be changed to be future proofed and every time we add
+        # new options to any of the commands it would need to be enabled
+        # in each backend if appropriate
+        if args.virtual_size and args.pool.type not in ["lvm", "thin"]:
+                err = "Backed '{0}' does not".format(args.pool.type) + \
+                      " support --virtual-size option!"
+                ssm_parser.parser_create.error(err)
 
     options.verbose = args.verbose
     options.force = args.force
@@ -1846,14 +2101,14 @@ def main(args=None):
     storage.set_globals(options)
 
     # Register clean-up function on exit
-    sys.exitfunc = misc.do_cleanup
+    atexit.register(misc.do_cleanup)
 
     if args.dry_run:
         return 0
 
     try:
         args.func(args)
-    except argparse.ArgumentTypeError, ex:
+    except argparse.ArgumentTypeError as ex:
         ssm_parser.parser.error(ex)
 
     return 0
diff --git a/ssmlib/misc.py b/ssmlib/misc.py
index 473568b..dce6ce6 100644
--- a/ssmlib/misc.py
+++ b/ssmlib/misc.py
@@ -23,11 +23,19 @@ import tempfile
 import threading
 import subprocess
 from ssmlib import problem
+from base64 import encode
 
 # List of temporary mount points which should be cleaned up
 # before exiting
 TMP_MOUNTED = []
 
+if sys.version < '3':
+    def __str__(x):
+        return str(x)
+else:
+    def __str__(x):
+        return str(x, encoding='utf-8', errors='strict')
+
 
 def get_unit_size(string):
     """
@@ -177,6 +185,23 @@ def get_real_size(size):
     raise Exception("Not supported unit in the " +
                     "size \'{0}\' argument.".format(size))
 
+def get_perc_size_argument(string):
+    """
+    Get percentage size argument. We now accept size argument in percentages
+    of - free pool/volume space (FREE)
+       - used pool/volume space (USED)
+       - total pool/original volume size
+    The accepted format is INTEGER%STRING where STRING needs to be one of
+    the following (FREE, USED, or empty)
+    """
+    p = re.compile(r'%')
+    perc, word = p.split(string, 1)
+
+    if is_number(perc) and word.upper() in ['FREE', 'USED', '']:
+        return (perc, word.upper())
+    else:
+        raise Exception("Not supported unit in the " +
+                        "size \'{0}\' argument.".format(string))
 
 def get_slaves(devname):
     return ["/dev/{0}".format(fname) for fname in os.listdir("/sys/block/{0}/slaves".format(devname))]
@@ -208,7 +233,7 @@ def get_file_size(path):
     file and returning offset. The returning size is in kilobytes.
     """
     with open(path, 'r') as f:
-        return os.lseek(f.fileno(), os.SEEK_SET, os.SEEK_END) / 1024
+        return os.lseek(f.fileno(), os.SEEK_SET, os.SEEK_END) // 1024
 
 
 def check_binary(name):
@@ -297,9 +322,16 @@ def get_swaps():
 
 def get_partitions():
     partitions = []
-    with open('/proc/partitions', 'r') as f:
-        for line in f.readlines()[2:]:
-            partitions.append(line.split())
+    new_line = []
+    output = run(["lsblk","-l","-b","-n","-p","-o","MAJ:MIN,SIZE,KNAME"], stdout=False)
+
+    for line in output[1].splitlines():
+        new_line = re.split('\s+|:',line.strip())
+        if len(new_line) == 4:
+            new_line[2] = int(new_line[2])//1024
+            partitions.append(new_line)
+        else:
+            pass
     return partitions
 
 
@@ -314,7 +346,7 @@ def get_mountinfo(regex=".*"):
                 continue
             array = line.split(None, 6)
             row = dict([(names[index], array[index])
-                for index in min(range(len(array) - 1), range(len(names)))])
+                for index in min(list(range(len(array) - 1)), list(range(len(names))))])
             array = line.rsplit(None, 3)
             row['fs'] = array[1]
             row['dev'] = array[2]
@@ -463,22 +495,25 @@ def run(cmd, show_cmd=False, stdout=False, stderr=True, can_fail=False,
     err_msg = "ERROR running command: \"{0}\"".format(" ".join(cmd))
     if proc.returncode != 0 and show_cmd:
         if output is not None:
-            print output
+            print(output)
         if error is not None:
-            print error
-        print >> sys.stderr, err_msg
+            print(error)
+        sys.stderr.write(err_msg + '\n')
 
     if proc.returncode != 0 and not can_fail:
         if output is not None:
-            print output
+            print(output)
         if error is not None:
-            print error
+            print(error)
         raise problem.CommandFailed(err_msg)
 
     if not return_stdout:
         output = None
 
-    return (proc.returncode, output)
+    if output is not None:
+        return (proc.returncode, __str__(output))
+    else:
+        return (proc.returncode, output)
 
 
 def chain(*iterables):
@@ -495,18 +530,39 @@ def chain(*iterables):
             yield element
 
 
-def izip(*iterables):
-    """
-    Make an iterator that aggregates elements from each of the iterables.
-    Like zip() except that it returns an iterator instead of a list. Used
-    for lock-step iteration over several iterables at a time. This code has
-    been taken from itertools python module.
-
-    izip('ABCD', 'xy') --> Ax By
-    """
-    iterators = map(iter, iterables)
-    while iterators:
-        yield tuple(map(next, iterators))
+if sys.version < '3':
+    def izip(*iterables):
+        """
+        Make an iterator that aggregates elements from each of the iterables.
+        Like zip() except that it returns an iterator instead of a list. Used
+        for lock-step iteration over several iterables at a time. This code has
+        been taken from itertools python module (Python 2).
+
+        izip('ABCD', 'xy') --> Ax By
+        """
+        iterators = map(iter, iterables)
+        while iterators:
+            yield tuple(map(next, iterators))
+else:
+    def izip(*iterables):
+        """
+        Make an iterator that aggregates elements from each of the iterables.
+        Like zip() except that it returns an iterator instead of a list. Used
+        for lock-step iteration over several iterables at a time. This code has
+        been taken from itertools python module (Python 3).
+
+        izip('ABCD', 'xy') --> Ax By
+        """
+        sentinel = object()
+        iterators = [iter(it) for it in iterables]
+        while iterators:
+            result = []
+            for it in iterators:
+                elem = next(it, sentinel)
+                if elem is sentinel:
+                    return
+                result.append(elem)
+            yield tuple(result)
 
 
 def compress(data, selectors):
@@ -534,8 +590,8 @@ def permutations(iterable, r=None):
     r = n if r is None else r
     if r > n:
         return
-    indices = range(n)
-    cycles = range(n, n - r, -1)
+    indices = list(range(n))
+    cycles = list(range(n, n - r, -1))
     yield tuple(pool[i] for i in indices[:r])
     while n:
         for i in reversed(range(r)):
@@ -605,5 +661,5 @@ def get_device_size(device):
     major, minor = divmod(info.st_rdev, 256)
     with open("/sys/dev/block/{0}:{1}/size".format(major, minor), 'r') as f:
         for line in f:
-            size = int(line)/2
+            size = int(line)//2
             return size
diff --git a/ssmlib/problem.py b/ssmlib/problem.py
index e1cdd81..a07637a 100644
--- a/ssmlib/problem.py
+++ b/ssmlib/problem.py
@@ -32,6 +32,7 @@ PROMPT_REMOVE =         4
 PROMPT_ADJUST =         5
 PROMPT_USE =            6
 PROMPT_CONTINUE =       7
+PROMPT_CREATE =         8
 
 PROMPT_MSG = [
         None,
@@ -42,6 +43,7 @@ PROMPT_MSG = [
         'Adjust',
         'Use anyway',
         'Continue',
+        'Create',
         ]
 
 # Define problem flags
@@ -232,6 +234,10 @@ class ProblemSet(object):
             ['\'{0}\' function is not implemented by {1}!',
             PROMPT_NONE, FL_FATAL, NotImplemented]
 
+        self.CREATE_DIRECTORY = \
+            ['Directory \'{0}\' does not exist!',
+             PROMPT_CREATE, FL_FORCE_YES, None]
+
     def _can_print_message(self, flags):
         if (flags & FL_DEBUG_ONLY):
             return self.options.debug
@@ -256,9 +262,10 @@ class ProblemSet(object):
 
     def _ask_question(self, flags):
         if flags & FL_DEFAULT_NO:
-            print "(N/y/q) ?",
+            sys.stdout.write("(N/y/q) ? ")
         else:
-            print "(Y/n/q) ?",
+            sys.stdout.write("(Y/n/q) ? ")
+        sys.stdout.flush()
         ch = ''
         if self.options.force and flags & FL_FORCE_NO:
             ch = 'N'
@@ -276,7 +283,7 @@ class ProblemSet(object):
                 ch = 'N'
             else:
                 ch = 'Y'
-        print ch
+        print(ch)
 
         if ch == 'Y':
             return True
@@ -301,9 +308,10 @@ class ProblemSet(object):
 
         if self._can_print_message(flags) and \
            (flags & FL_MSG_ONLY or prompt_msg is None):
-            print >> sys.stderr, message
+            sys.stderr.write(message + "\n")
         if not flags & FL_MSG_ONLY and prompt_msg is not None:
-            print message, '{0}'.format(prompt_msg),
+            sys.stdout.write(message + " ")
+            sys.stdout.write('{0}'.format(prompt_msg) + " ")
             res = self._ask_question(flags)
 
         if (flags & FL_FATAL):
diff --git a/test.py b/test.py
index 7c91ae8..414f8c8 100644
--- a/test.py
+++ b/test.py
@@ -51,44 +51,44 @@ def run_bash_tests():
         if not re.match("^\d\d\d-.*\.sh$", script):
             continue
         count += 1
-        print "{0:<29}".format(script),
+        sys.stdout.write("{0:<29}".format(script) + " ")
         sys.stdout.flush()
         bad_file = re.sub("\.sh$",".bad", script)
         if os.access(bad_file, os.R_OK):
             os.remove(bad_file)
         ret, out = misc.run(['./' + script], stdout=False, can_fail=True)
         if ret:
-            print "\033[91m[FAILED]\033[0m"
+            print("\033[91m[FAILED]\033[0m")
             failed.append(script)
             with open(bad_file, 'w') as f:
                 f.write(out)
         elif re.search("Traceback", out):
             # There should be no tracebacks in the output
             out += "\nWARNING: Traceback in the output!\n"
-            print "\033[93m[WARNING]\033[0m"
+            print("\033[93m[WARNING]\033[0m")
             with open(bad_file, 'w') as f:
                 f.write(out)
         else:
-            print "\033[92m[PASSED]\033[0m"
+            print("\033[92m[PASSED]\033[0m")
             passed.append(script)
     t1 = time.time() - t0
-    print "Ran {0} tests in {1} seconds.".format(count, round(t1, 2))
-    print "{0} tests PASSED: {1}".format(len(passed), ", ".join(passed))
+    print("Ran {0} tests in {1} seconds.".format(count, round(t1, 2)))
+    print("{0} tests PASSED: {1}".format(len(passed), ", ".join(passed)))
     ret = 0
     if len(failed) > 0:
-        print "{0} tests FAILED: {1}".format(len(failed), ", ".join(failed))
-        print "See files with \"bad\" extension for output"
+        print("{0} tests FAILED: {1}".format(len(failed), ", ".join(failed)))
+        print("See files with \"bad\" extension for output")
         ret = 1
     # Show coverage report output if possible
     if misc.check_binary('coverage'):
-        print "[+] Coverage"
+        print("[+] Coverage")
         misc.run(['coverage', 'report'], stdout=True, can_fail=True)
     os.chdir(cur)
     return ret
 
 
 def quick_test():
-    print "[+] Running doctests"
+    print("[+] Running doctests")
     doctest_flags = doctest.IGNORE_EXCEPTION_DETAIL | doctest.ELLIPSIS | \
                     doctest.REPORT_ONLY_FIRST_FAILURE
     result = doctest.testmod(main, exclude_empty=True, report=True,
@@ -101,12 +101,13 @@ def quick_test():
             raise_on_error=False, optionflags=doctest_flags)
     result = doctest.testmod(misc, exclude_empty=True, report=True,
             raise_on_error=False, optionflags=doctest_flags)
-    print "[+] Running unittests"
+    print("[+] Running unittests")
     test_loader = unittest.TestLoader()
     tests_lvm = test_loader.loadTestsFromModule(test_lvm)
     tests_btrfs = test_loader.loadTestsFromModule(test_btrfs)
     tests_ssm = test_loader.loadTestsFromModule(test_ssm)
     tests = unittest.TestSuite([tests_lvm, tests_btrfs, tests_ssm])
+    tests = unittest.TestSuite([tests_ssm])
     test_runner = unittest.TextTestRunner(verbosity=2)
     test_runner.run(tests)
 
@@ -114,8 +115,8 @@ def quick_test():
 if __name__ == '__main__':
     quick_test()
     if not os.geteuid() == 0:
-        print "\nRoot privileges required to run more tests!\n"
+        print("\nRoot privileges required to run more tests!\n")
         sys.exit(0)
-    print "[+] Running bash tests"
+    print("[+] Running bash tests")
     result = run_bash_tests()
     sys.exit(result)
diff --git a/tests/bashtests/001-lvm-add.sh b/tests/bashtests/001-lvm-add.sh
index cfe95da..bdb57df 100755
--- a/tests/bashtests/001-lvm-add.sh
+++ b/tests/bashtests/001-lvm-add.sh
@@ -22,7 +22,8 @@ export test_description='Exercise ssm add'
 
 export COLUMNS=1024
 DEV_COUNT=10
-aux prepare_devs $DEV_COUNT 10
+DEV_SIZE=10
+aux prepare_devs $DEV_COUNT $DEV_SIZE
 TEST_DEVS=$(cat DEVICES)
 export SSM_DEFAULT_BACKEND='lvm'
 export SSM_LVM_DEFAULT_POOL=$vg1
@@ -175,6 +176,33 @@ check vg_field $pool1 pv_count 1
 check vg_field $SSM_LVM_DEFAULT_POOL pv_count 1
 ssm  -f remove --all
 
+# Some basic thin tests
+export TVOL_PREFIX="tvol"
+tvol1=${TVOL_PREFIX}001
+tpool1=${SSM_LVM_DEFAULT_POOL}_thin001
+
+# Create thin volume
+virtualsize=$(($DEV_SIZE*10))
+ssm create --virtual-size ${virtualsize}M $dev1 $dev2 $dev3
+virtualsize=$(align_size_up $virtualsize)
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 3 none none 24.00MB
+check list_table "$(ssm list pool)" $tpool1 thin 3 none none 16.00MB $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB thin
+# Add device to the thin pool
+ssm add -p $tpool1 $dev4
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 4
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 4
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 4 none none 32.00MB
+check list_table "$(ssm list pool)" $tpool1 thin 4 none none 24.00MB $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB thin
+ssm  -f remove --all
+
 ssm add --help
 
 # Some cases which should fail
diff --git a/tests/bashtests/002-lvm-create.sh b/tests/bashtests/002-lvm-create.sh
index d316e5d..fee20a0 100755
--- a/tests/bashtests/002-lvm-create.sh
+++ b/tests/bashtests/002-lvm-create.sh
@@ -22,13 +22,14 @@ test_description='Exercise ssm create'
 
 DEV_COUNT=10
 DEV_SIZE=100
-TEST_MAX_SIZE=$(($DEV_COUNT*$DEV_SIZE))
+TEST_MAX_SIZE=$(($DEV_COUNT*($DEV_SIZE-4)))
 aux prepare_devs $DEV_COUNT $DEV_SIZE
 aux prepare_mnts 4
 TEST_DEVS=$(cat DEVICES)
 export SSM_DEFAULT_BACKEND='lvm'
 export SSM_LVM_DEFAULT_POOL=$vg1
 export LVOL_PREFIX="lvol"
+export TVOL_PREFIX="tvol"
 export SSM_NONINTERACTIVE='1'
 lvol1=${LVOL_PREFIX}001
 lvol2=${LVOL_PREFIX}002
@@ -43,6 +44,17 @@ which mkfs.ext3 && TEST_FS+="ext3 "
 which mkfs.ext4 && TEST_FS+="ext4 "
 which mkfs.xfs  && TEST_FS+="xfs"
 
+# Some basic thin tests
+tvol1=${TVOL_PREFIX}001
+tvol2=${TVOL_PREFIX}002
+tvol3=${TVOL_PREFIX}003
+tvol4=${TVOL_PREFIX}004
+
+tpool1=${SSM_LVM_DEFAULT_POOL}_thin001
+tpool2=${SSM_LVM_DEFAULT_POOL}_thin002
+tpool3=${SSM_LVM_DEFAULT_POOL}_thin003
+
+
 # Create with single device
 ssm create $dev1
 ssm create -p $pool1 $dev2
@@ -96,6 +108,43 @@ check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 10 360.00MB 600.00
 check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$lvol1 $SSM_LVM_DEFAULT_POOL 600.00MB linear
 ssm -f remove $SSM_LVM_DEFAULT_POOL
 
+# Create a logical volume specifying size as percentage
+ssm add $TEST_DEVS
+ssm create -s 50%
+not ssm create -s 80%
+size=$((TEST_MAX_SIZE/2))
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$((TEST_MAX_SIZE/4))
+ssm create -s 50%free
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol2 lv_size ${size}.00m
+ssm create -s 20%used
+size=$((($TEST_MAX_SIZE-$size)/5))
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol3 lv_size ${size}.00m
+ssm -f remove $SSM_LVM_DEFAULT_POOL
+
+# Create a logical volume specifying size and adding devices
+ssm create -s 100% $dev1 $dev2 $dev3 $dev4 $dev5
+size=$((5*($DEV_SIZE-4)))
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+ssm create -s 50%FREE $dev6 $dev7
+size=$(($DEV_SIZE-4))
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol2 lv_size ${size}.00m
+ssm create -s 20%USED $TEST_DEVS
+size=$(((6*($DEV_SIZE-4))/5))
+size=$(align_size_up $size)
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol3 lv_size ${size}.00m
+ssm -f remove $SSM_LVM_DEFAULT_POOL
+
+not ssm create -s 200% $dev1 $dev2 $dev3 $dev4 $dev5
+ssm create -s 50% $TEST_DEVS
+not ssm create -s 200%free
+not ssm create -s 200%used
+ssm -f remove $SSM_LVM_DEFAULT_POOL
+ssm create -s 50% $dev1 $dev2 $dev3 $dev4 $dev5
+not ssm create -s 500%free $dev6 $dev7
+not ssm create -s 500%used $dev8 $dev9
+ssm -f remove $SSM_LVM_DEFAULT_POOL
+
 # Create a striped logical volume
 not ssm create -I 32 $TEST_DEVS
 ssm create -r 0 -I 32 $TEST_DEVS
@@ -334,6 +383,147 @@ check lv_field $pool1/$lvol1 pv_count 1
 check vg_field $SSM_LVM_DEFAULT_POOL pv_count 1
 ssm  -f remove --all
 
+# Some basic thin tests
+tvol1=${TVOL_PREFIX}001
+tvol2=${TVOL_PREFIX}002
+tvol3=${TVOL_PREFIX}003
+tvol4=${TVOL_PREFIX}004
+
+tpool1=${SSM_LVM_DEFAULT_POOL}_thin001
+tpool2=${SSM_LVM_DEFAULT_POOL}_thin002
+tpool3=${SSM_LVM_DEFAULT_POOL}_thin003
+
+
+# Create thin volume smaller than pool
+virtualsize=$(($DEV_SIZE/2))
+ssm create --virtual-size ${virtualsize}M $dev1 $dev2 $dev3
+virtualsize=$(align_size_up $virtualsize)
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 3 none none none
+check list_table "$(ssm list pool)" $tpool1 thin 3 none none none $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB thin
+ssm  -f remove --all
+
+# Create thin volume bigger than pool + mount
+virtualsize=$(($DEV_SIZE*10))
+ssm create --fs ext4 --virtual-size ${virtualsize}M $dev1 $dev2 $dev3 $mnt1
+virtualsize=$(align_size_up $virtualsize)
+check mountpoint $SSM_LVM_DEFAULT_POOL-$tvol1 $mnt1
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 3 none none none
+check list_table "$(ssm list pool)" $tpool1 thin 3 none none none $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB ext4 none none thin
+umount $mnt1
+ssm  -f remove --all
+
+# Create this volume smaller than pool with thin pool size specified and mount
+virtualsize=$(($DEV_SIZE/2))
+size=$(($DEV_SIZE))
+ssm create --fs ext4 --size ${size}M --virtual-size ${virtualsize}M $dev1 $dev2 $dev3 $mnt1
+virtualsize=$(align_size_up $virtualsize)
+size=$(align_size_up $size)
+check mountpoint $SSM_LVM_DEFAULT_POOL-$tvol1 $mnt1
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 3 none none none
+check list_table "$(ssm list pool)" $tpool1 thin 3 none none ${size}.00MB $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB ext4 none none thin
+umount $mnt1
+ssm  -f remove --all
+
+# Create this volume bigger than pool with thin pool size specified
+virtualsize=$(($DEV_SIZE*10))
+size=$(($DEV_SIZE))
+ssm create --size ${size}M --virtual-size ${virtualsize}M $dev1 $dev2 $dev3
+virtualsize=$(align_size_up $virtualsize)
+size=$(align_size_up $size)
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 3 none none none
+check list_table "$(ssm list pool)" $tpool1 thin 3 none none ${size}.00MB $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB thin
+ssm  -f remove --all
+
+# Create new thin volume out of existing thin pool
+virtualsize=$(($DEV_SIZE*10))
+ssm create --virtual-size ${virtualsize}M $dev1 $dev2 $dev3
+# --size, or --virtual-size can be specified when creathing thin volume from thin pool
+ssm create -p $tpool1 --virtual-size ${virtualsize}M
+ssm create --fs ext4 -p $tpool1 --size ${virtualsize}M $mnt1
+# Size needs to be specified in order to create thin volume from thin pool
+not ssm create -p $tpool1
+virtualsize=$(align_size_up $virtualsize)
+check mountpoint $SSM_LVM_DEFAULT_POOL-$tvol3 $mnt1
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol2 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol3 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol2 segtype thin
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol3 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 3 none none none
+check list_table "$(ssm list pool)" $tpool1 thin 3 none none none $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB thin
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol2 $tpool1 ${virtualsize}.00MB thin
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol3 $tpool1 ${virtualsize}.00MB ext4 none none thin
+# Add device into the pool as well
+ssm create -p $tpool1 --virtual-size ${virtualsize}M $dev4
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 4
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 4
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol4 lv_size ${virtualsize}.00m
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 4 none none none
+check list_table "$(ssm list pool)" $tpool1 thin 4 none none none $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol4 $tpool1 ${virtualsize}.00MB thin
+umount $mnt1
+ssm  -f remove --all
+
+# Create new thin volume out of existing lvm pool
+virtualsize=$(($DEV_SIZE*10))
+ssm add $dev1 $dev2 $dev3
+ssm create --fs ext4 -p $SSM_LVM_DEFAULT_POOL --virtual-size ${virtualsize}M $mnt1
+virtualsize=$(align_size_up $virtualsize)
+check mountpoint $SSM_LVM_DEFAULT_POOL-$tvol1 $mnt1
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 3 none none none
+check list_table "$(ssm list pool)" $tpool1 thin 3 none none none $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB ext4 none none thin
+# Add device into the pool as well
+ssm create -p $SSM_LVM_DEFAULT_POOL --virtual-size ${virtualsize}M $dev4 $dev5
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 5
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool2 pv_count 5
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol2 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol2 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 5 none none none
+check list_table "$(ssm list pool)" $tpool2 thin 5 none none none $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol2 $tpool2 ${virtualsize}.00MB thin
+# Add device into the pool as well specifying size
+size=$(($DEV_SIZE))
+ssm create -p $SSM_LVM_DEFAULT_POOL --size ${size}M --virtual-size ${virtualsize}M $dev6 $dev7
+size=$(align_size_up $size)
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 7
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool3 pv_count 7
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol3 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol3 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 7 none none none
+check list_table "$(ssm list pool)" $tpool3 thin 7 none none ${size}.00MB $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol3 $tpool3 ${virtualsize}.00MB thin
+umount $mnt1
+ssm  -f remove --all
+
 ssm create --help
 
 # Some cases which should fail
diff --git a/tests/bashtests/003-lvm-remove.sh b/tests/bashtests/003-lvm-remove.sh
index e8333d0..760336a 100755
--- a/tests/bashtests/003-lvm-remove.sh
+++ b/tests/bashtests/003-lvm-remove.sh
@@ -45,7 +45,6 @@ which mkfs.ext3 && _FS="ext3"
 which mkfs.ext4 && _FS="ext4"
 which mkfs.xfs  && _FS="xfs"
 
-
 TEST_MNT=$TESTDIR/mnt
 
 # Remove logical volume
@@ -54,12 +53,43 @@ check lv_field $DEFAULT_VOLUME lv_name $lvol1
 ssm -f remove $DEFAULT_VOLUME
 not check lv_field $DEFAULT_VOLUME lv_name $lvol1
 
+# Remove inactive logical volume
+ssm create $TEST_DEVS
+check lv_field $DEFAULT_VOLUME lv_name $lvol1
+lvchange -an $DEFAULT_VOLUME
+ssm -f remove $DEFAULT_VOLUME
+not check lv_field $DEFAULT_VOLUME lv_name $lvol1
+
 # Remove volume group
 ssm create $TEST_DEVS
 check vg_field $SSM_LVM_DEFAULT_POOL vg_name $SSM_LVM_DEFAULT_POOL
 ssm -f remove $SSM_LVM_DEFAULT_POOL
 not check vg_field $SSM_LVM_DEFAULT_POOL vg_name $SSM_LVM_DEFAULT_POOL
 
+# Some basic thin tests
+export TVOL_PREFIX="tvol"
+tvol1=${TVOL_PREFIX}001
+tpool1=${SSM_LVM_DEFAULT_POOL}_thin001
+
+# Remove thin volume
+virtualsize=$(($DEV_SIZE*10))
+ssm create --virtual-size ${virtualsize}M $dev1 $dev2 $dev3
+check lv_field ${SSM_LVM_DEFAULT_POOL}/$tpool1 lv_name $tpool1
+check lv_field ${SSM_LVM_DEFAULT_POOL}/$tvol1 lv_name $tvol1
+ssm -f remove ${SSM_LVM_DEFAULT_POOL}/$tvol1
+not check lv_field ${SSM_LVM_DEFAULT_POOL}/$tvol1 lv_name $tvol1
+check lv_field ${SSM_LVM_DEFAULT_POOL}/$tpool1 lv_name $tpool1
+# Remove thin pool
+ssm -f remove $tpool1
+not check lv_field ${SSM_LVM_DEFAULT_POOL}/$tpool1 lv_name $tpool1
+
+# Remove thin pool with volume
+ssm create --virtual-size ${virtualsize}M $dev1 $dev2 $dev3
+check lv_field ${SSM_LVM_DEFAULT_POOL}/$tpool1 lv_name $tpool1
+check lv_field ${SSM_LVM_DEFAULT_POOL}/$tvol1 lv_name $tvol1
+ssm -f remove $tpool1
+not check lv_field ${SSM_LVM_DEFAULT_POOL}/$tpool1 lv_name $tpool1
+not check lv_field ${SSM_LVM_DEFAULT_POOL}/$tvol1 lv_name $tvol1
 
 # Remove unused devices from the pool
 ssm create $dev1 $dev2 $dev3
diff --git a/tests/bashtests/004-lvm-resize.sh b/tests/bashtests/004-lvm-resize.sh
index 6b9b341..b02fc9b 100755
--- a/tests/bashtests/004-lvm-resize.sh
+++ b/tests/bashtests/004-lvm-resize.sh
@@ -169,6 +169,45 @@ ssm resize --size +${DEV_SIZE}M $SSM_LVM_DEFAULT_POOL/$lvol1 $dev2 $dev3
 check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 pv_count 3
 ssm -f remove $SSM_LVM_DEFAULT_POOL
 
+# Resize using percentage of the size
+ssm create $TEST_DEVS
+size=$(($TEST_MAX_SIZE/2))
+ssm -f resize -s-50% $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$(($size+($size/4)))
+ssm resize -s +25% $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$TEST_MAX_SIZE
+ssm resize -s +100%FREE $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$(($TEST_MAX_SIZE/2))
+ssm -f resize -s-50%USED $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$((($TEST_MAX_SIZE/2)+($size/2)))
+ssm resize -s +50%USED $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$(($size-($size/2)))
+ssm -f resize -s-50%USED $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+
+# Resize using percentage of the size
+size=$TEST_MAX_SIZE
+ssm resize -s +100%FREE $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$(($TEST_MAX_SIZE/4))
+ssm -f resize --size 25% $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$(($TEST_MAX_SIZE/2))
+ssm resize --size 200% $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$(($TEST_MAX_SIZE/4))
+ssm -f resize --size 50%free $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+size=$(($TEST_MAX_SIZE/2))
+ssm resize --size 200%used $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 lv_size ${size}.00m
+not ssm resize --size +1000% $SSM_LVM_DEFAULT_POOL/$lvol1
+ssm -f remove $SSM_LVM_DEFAULT_POOL
 
 ssm add $dev{1,2,3}
 ssm create -s ${DEV_SIZE}M
@@ -243,6 +282,67 @@ ssm -f resize -s +$((DEV_SIZE/2))M  $SSM_LVM_DEFAULT_POOL/$lvol1 $dev2
 check vg_field $SSM_LVM_DEFAULT_POOL pv_count 2
 ssm -f remove --all
 
+# Some basic thin tests
+export TVOL_PREFIX="tvol"
+tvol1=${TVOL_PREFIX}001
+tpool1=${SSM_LVM_DEFAULT_POOL}_thin001
+
+# Resize thin volume
+virtualsize=$(($DEV_SIZE*10))
+ssm create --virtual-size ${virtualsize}M $dev1 $dev2 $dev3
+virtualsize=$(align_size_up $virtualsize)
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count 3
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check list_table "$(ssm list pool)" $SSM_LVM_DEFAULT_POOL lvm 3 none none none
+check list_table "$(ssm list pool)" $tpool1 thin 3 none none none $SSM_LVM_DEFAULT_POOL
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB thin
+# Increase size of the thin volume
+ssm -f resize --size 100G ${DM_DEV_DIR}/$SSM_LVM_DEFAULT_POOL/$tvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size 100.00g
+ssm -f resize --size +100G ${DM_DEV_DIR}/$SSM_LVM_DEFAULT_POOL/$tvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size 200.00g
+ssm -f resize --size +10% ${DM_DEV_DIR}/$SSM_LVM_DEFAULT_POOL/$tvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size 220.00g
+ssm -f resize --size 50% ${DM_DEV_DIR}/$SSM_LVM_DEFAULT_POOL/$tvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size 110.00g
+# Decrease size of the thin volume
+ssm -f resize --size 100G ${DM_DEV_DIR}/$SSM_LVM_DEFAULT_POOL/$tvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size 100.00g
+ssm -f resize -s-50% ${DM_DEV_DIR}/$SSM_LVM_DEFAULT_POOL/$tvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size 50.00g
+ssm -f resize -s-10G ${DM_DEV_DIR}/$SSM_LVM_DEFAULT_POOL/$tvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size 40.00g
+ssm -f resize -s200% ${DM_DEV_DIR}/$SSM_LVM_DEFAULT_POOL/$tvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size 80.00g
+ssm  -f remove --all
+
+# Resize thin pool
+virtualsize=$(($DEV_SIZE*10))
+size=$(($DEV_SIZE*2))
+ssm create --size ${size}M --virtual-size ${virtualsize}M $TEST_DEVS
+virtualsize=$(align_size_up $virtualsize)
+size=$(align_size_up $size)
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count $DEV_COUNT
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 lv_size ${size}.00m
+check list_table "$(ssm list pool)" $tpool1 thin $DEV_COUNT none none ${size}.00MB $SSM_LVM_DEFAULT_POOL
+# Increase size of the thin pool
+size=$(($DEV_SIZE*3))
+ssm resize --size ${size}M $SSM_LVM_DEFAULT_POOL/$tpool1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 lv_size ${size}.00m
+size=$(($DEV_SIZE*4))
+ssm resize --size +${DEV_SIZE}M $SSM_LVM_DEFAULT_POOL/$tpool1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 lv_size ${size}.00m
+size=$(($DEV_SIZE*6))
+ssm resize --size +50% $SSM_LVM_DEFAULT_POOL/$tpool1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 lv_size ${size}.00m
+size=$(($DEV_SIZE*9))
+ssm resize --size 150% $SSM_LVM_DEFAULT_POOL/$tpool1
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 lv_size ${size}.00m
+not ssm resize --size 500% $SSM_LVM_DEFAULT_POOL/$tpool1
+ssm  -f remove --all
+
 ssm resize --help
 
 # Some cases which should fail
diff --git a/tests/bashtests/005-lvm-snapshot.sh b/tests/bashtests/005-lvm-snapshot.sh
index e0778bd..a353562 100755
--- a/tests/bashtests/005-lvm-snapshot.sh
+++ b/tests/bashtests/005-lvm-snapshot.sh
@@ -40,6 +40,7 @@ pool1=$vg2
 pool2=$vg3
 
 TEST_MNT=$TESTDIR/mnt
+TEST_MNT2=$TESTDIR/mnt2
 
 # Create volume with all devices at once
 size=$(($DEV_SIZE*6))
@@ -85,7 +86,22 @@ check lv_field $SSM_LVM_DEFAULT_POOL/$snap2 lv_size ${snap_size}.00m
 ssm snapshot --size ${snap_size}M --name $snap3 $SSM_LVM_DEFAULT_POOL/$lvol1
 check lv_field $SSM_LVM_DEFAULT_POOL/$snap3 lv_size ${snap_size}.00m
 check vg_field $SSM_LVM_DEFAULT_POOL lv_count 4
+ssm -f remove $SSM_LVM_DEFAULT_POOL/$snap1 $SSM_LVM_DEFAULT_POOL/$snap2 $SSM_LVM_DEFAULT_POOL/$snap3
 
+# Take a snapshot with defined size as percentage
+snap_size=$(($size/10))
+snap_size=$(align_size_up $snap_size)
+ssm snapshot --size 10% --name $snap1 $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$snap1 lv_size ${snap_size}.00m
+snap_size=$(($size/4))
+snap_size=$(align_size_up $snap_size)
+ssm snapshot --size 25% --name $snap2 $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$snap2 lv_size ${snap_size}.00m
+snap_size=$(($size/5))
+snap_size=$(align_size_up $snap_size)
+ssm snapshot --size 20% --name $snap3 $SSM_LVM_DEFAULT_POOL/$lvol1
+check lv_field $SSM_LVM_DEFAULT_POOL/$snap3 lv_size ${snap_size}.00m
+check vg_field $SSM_LVM_DEFAULT_POOL lv_count 4
 ssm -f remove --all
 
 # Create a logical volume with file system and mount it
@@ -102,10 +118,13 @@ check lv_field $SSM_LVM_DEFAULT_POOL/$snap2 lv_size ${snap_size}.00m
 ssm snapshot --name $snap3 $TEST_MNT
 check lv_field $SSM_LVM_DEFAULT_POOL/$snap3 lv_size ${snap_size}.00m
 check vg_field $SSM_LVM_DEFAULT_POOL lv_count 4
+# Mount snapshot
+[ ! -d $TEST_MNT2 ] && mkdir $TEST_MNT2 &> /dev/null
+ssm mount $SSM_LVM_DEFAULT_POOL/$snap3 $TEST_MNT2
 ssm_output=$(ssm list snap)
 check list_table "$ssm_output" $snap1 $lvol1 $SSM_LVM_DEFAULT_POOL ${snap_size}.00MB none linear
 check list_table "$ssm_output" $snap2 $lvol1 $SSM_LVM_DEFAULT_POOL ${snap_size}.00MB none linear
-check list_table "$ssm_output" $snap3 $lvol1 $SSM_LVM_DEFAULT_POOL ${snap_size}.00MB none linear
+check list_table "$ssm_output" $snap3 $lvol1 $SSM_LVM_DEFAULT_POOL ${snap_size}.00MB none linear $TEST_MNT2
 check list_table "$(ssm list fs)" $lvol1 $SSM_LVM_DEFAULT_POOL ${size}.00MB ext4 ${size}.00MB none linear $TEST_MNT
 
 # Remove the snapshot volumes
@@ -122,6 +141,7 @@ check lv_field $SSM_LVM_DEFAULT_POOL/$snap3 lv_size ${snap_size}.00m
 check vg_field $SSM_LVM_DEFAULT_POOL lv_count 4
 
 umount $TEST_MNT
+not umount $TEST_MNT2
 
 ssm -f remove --all
 
@@ -154,3 +174,25 @@ ssm add $dev3
 not ssm snapthot -s $((DEV_SIZE*2)) -n $snap1 $SSM_LVM_DEFAULT_POOL/$lvol1
 check vg_field $SSM_LVM_DEFAULT_POOL lv_count 1
 ssm -f remove --all
+
+# Some basic thin tests
+export TVOL_PREFIX="tvol"
+tvol1=${TVOL_PREFIX}001
+tpool1=${SSM_LVM_DEFAULT_POOL}_thin001
+
+# Snapshot thin volume
+virtualsize=$(($DEV_SIZE*10))
+ssm create --virtual-size ${virtualsize}M $TEST_DEVS
+virtualsize=$(align_size_up $virtualsize)
+check vg_field $SSM_LVM_DEFAULT_POOL pv_count $DEV_COUNT
+check lv_field $SSM_LVM_DEFAULT_POOL/$tpool1 pv_count $DEV_COUNT
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 lv_size ${virtualsize}.00m
+check lv_field $SSM_LVM_DEFAULT_POOL/$tvol1 segtype thin
+check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$tvol1 $tpool1 ${virtualsize}.00MB thin
+ssm snapshot --name $snap1 $SSM_LVM_DEFAULT_POOL/$tvol1
+ssm snapshot --name $snap2 $DM_DEV_DIR/$SSM_LVM_DEFAULT_POOL/$tvol1
+check list_table "$(ssm list snap)" $snap1 $tvol1 $tpool1 none thin
+check list_table "$(ssm list snap)" $snap2 $tvol1 $tpool1 none thin
+not ssm snapshot --size ${DEV_SIZE}M --name $snap1 $SSM_LVM_DEFAULT_POOL/$tvol1
+not ssm snapshot --size ${DEV_SIZE}M --name $snap2 $SSM_LVM_DEFAULT_POOL/$tvol1
+ssm  -f remove --all
diff --git a/tests/bashtests/011-lvm-list.sh b/tests/bashtests/011-lvm-list.sh
index 73cea90..e9eb80a 100755
--- a/tests/bashtests/011-lvm-list.sh
+++ b/tests/bashtests/011-lvm-list.sh
@@ -80,6 +80,7 @@ ssm add -p $pool3 $dev{5,6,7,8}
 ssm create -p $pool3 -s ${size4}m -n $vol4
 ssm create -p $pool3 -s ${size5}m -n $vol5
 ssm create -p $pool3 -s ${size6}m -n $vol6
+lvchange -an $pool3/$vol6
 
 # We shouldn't see ssm list fs here
 test `ssm list fs | wc -l` -le 1
diff --git a/tests/bashtests/012-crypt-create.sh b/tests/bashtests/012-crypt-create.sh
old mode 100644
new mode 100755
index 8a5fddb..586bdf0
--- a/tests/bashtests/012-crypt-create.sh
+++ b/tests/bashtests/012-crypt-create.sh
@@ -47,6 +47,13 @@ pass() {
 	echo -e "${passwd}\n${passwd}"
 }
 
+fs1=ext4
+fs2=ext4
+fs3=ext4
+fs4=ext4
+which mkfs.ext2 && grep -E "^\sext[234]$" /proc/filesystems && fs2=ext2
+which mkfs.ext3 && grep -E "^\sext[34]$" /proc/filesystems && fs3=ext3
+which mkfs.xfs  && grep -E "^\sxfs$" /proc/filesystems && fs4=xfs
 
 # Create encrypted volume
 pass | ssm create $dev1
@@ -64,21 +71,21 @@ check crypt_vol_field $crypt_vol3 type LUKS1
 check crypt_vol_field $crypt_vol3 device $dev3
 check list_table "$(ssm list vol)" $crypt_vol3 $SSM_CRYPT_DEFAULT_POOL none crypt
 
-pass | ssm create --fs ext4 -e plain $dev4 $mnt1
+pass | ssm create --fs $fs1 -e plain $dev4 $mnt1
 check mountpoint $crypt_vol4 $mnt1
 check crypt_vol_field $crypt_vol4 type PLAIN
 check crypt_vol_field $crypt_vol4 device $dev4
-check list_table "$(ssm list vol)" $crypt_vol4 $SSM_CRYPT_DEFAULT_POOL none ext4 none none crypt
+check list_table "$(ssm list vol)" $crypt_vol4 $SSM_CRYPT_DEFAULT_POOL none $fs1 none none crypt
 ssm list
 umount $mnt1
 ssm -f remove ${DEV}/$crypt_vol1
 
-pass | ssm create --fs ext3 -s 50M -e plain $dev1 $mnt1
+pass | ssm create --fs $fs2 -s 50M -e plain $dev1 $mnt1
 check mountpoint $crypt_vol1 $mnt1
 check crypt_vol_field $crypt_vol1 type PLAIN
 check crypt_vol_field $crypt_vol1 device $dev1
 check crypt_vol_field $crypt_vol1 size 102400
-check list_table "$(ssm list vol)" $crypt_vol1 $SSM_CRYPT_DEFAULT_POOL none ext3 none none crypt
+check list_table "$(ssm list vol)" $crypt_vol1 $SSM_CRYPT_DEFAULT_POOL none $fs2 none none crypt
 umount $mnt1
 
 ssm remove ${DEV}/$crypt_vol1 ${DEV}/$crypt_vol3 ${DEV}/$crypt_vol2 ${DEV}/$crypt_vol4
@@ -95,11 +102,11 @@ lvol3=${LVOL_PREFIX}003
 lvol4=${LVOL_PREFIX}004
 export SSM_DEFAULT_BACKEND='lvm'
 
-pass | ssm create --fs xfs $dev1 $dev2 $mnt1 -e
+pass | ssm create --fs $fs3 $dev1 $dev2 $mnt1 -e
 check mountpoint $crypt_vol1 $mnt1
 check crypt_vol_field $crypt_vol1 type LUKS1
 check crypt_vol_field $crypt_vol1 device ${SSM_LVM_DEFAULT_POOL}-$lvol1
-check list_table "$(ssm list vol)" $crypt_vol1 $SSM_CRYPT_DEFAULT_POOL none xfs none none crypt
+check list_table "$(ssm list vol)" $crypt_vol1 $SSM_CRYPT_DEFAULT_POOL none $fs3 none none crypt
 check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$lvol1 $SSM_LVM_DEFAULT_POOL none linear
 check lv_field $SSM_LVM_DEFAULT_POOL/$lvol1 pv_count 2
 
@@ -117,11 +124,11 @@ check list_table "$(ssm list vol)" $crypt_vol3 $SSM_CRYPT_DEFAULT_POOL none cryp
 check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$lvol3 $SSM_LVM_DEFAULT_POOL none linear
 check lv_field $SSM_LVM_DEFAULT_POOL/$lvol3 pv_count 5
 
-pass | ssm create -e plain --fs xfs -r10 -s ${DEV_SIZE}M $dev6 $dev7 $dev8 $dev9 $mnt2
+pass | ssm create -e plain --fs $fs4 -r10 -s ${DEV_SIZE}M $dev6 $dev7 $dev8 $dev9 $mnt2
 check mountpoint $crypt_vol4 $mnt2
 check crypt_vol_field $crypt_vol4 type PLAIN
 check crypt_vol_field $crypt_vol4 device ${SSM_LVM_DEFAULT_POOL}-$lvol4
-check list_table "$(ssm list vol)" $crypt_vol4 $SSM_CRYPT_DEFAULT_POOL 104.00M xfs none none crypt
+check list_table "$(ssm list vol)" $crypt_vol4 $SSM_CRYPT_DEFAULT_POOL 104.00M $fs4 none none crypt
 check list_table "$(ssm list vol)" $SSM_LVM_DEFAULT_POOL/$lvol4 $SSM_LVM_DEFAULT_POOL 104.00M raid10
 check lv_field $SSM_LVM_DEFAULT_POOL/$lvol4 pv_count 9
 
diff --git a/tests/bashtests/lib/check.sh b/tests/bashtests/lib/check.sh
index bd4028e..aa4dbdb 100644
--- a/tests/bashtests/lib/check.sh
+++ b/tests/bashtests/lib/check.sh
@@ -418,10 +418,22 @@ mountpoint()
 		echo usage: mountpoint dev mountpoint
 		exit 1
 	fi
-	if ! grep "$1.*$2" /proc/mounts ; then
+	if ! grep "$1[[:space:]]$2" /proc/mounts ; then
 		echo error creating volume $1 with mountpoint at $2
 		exit 1
 	fi
+	if [ ! $# -gt 2 ] ; then
+		exit 0
+	fi
+	line=$(grep "$1[[:space:]]$2" /proc/mounts)
+	IFS=','
+	for option in $3; do
+		if ! echo $line | grep "$1[[:space:]]$2.*$option" ; then
+			echo "error mounting with mount options $3 \($1 at $2\)"
+			exit 1
+		fi
+		echo "Option $option found!"
+	done
 	exit 0
 }
 
diff --git a/tests/unittests/common.py b/tests/unittests/common.py
index a255c43..16cdb5a 100644
--- a/tests/unittests/common.py
+++ b/tests/unittests/common.py
@@ -128,10 +128,11 @@ class MockSystemDataSource(unittest.TestCase):
             cmd = command + " " + " ".join(case)
             main.main(cmd)
             if expected:
-		if NotEq:
-			self._cmdNotEq(expected)
-		else:
-			self._cmdEq(expected)
+                if NotEq:
+                    self._cmdNotEq(expected)
+                else:
+                    self._cmdEq(expected)
+
 
     def mock_run(self, cmd, *args, **kwargs):
         self.run_data.append(" ".join(cmd))
@@ -148,9 +149,9 @@ class MockSystemDataSource(unittest.TestCase):
 
     def mock_get_partitions(self):
         partitions = []
-        for name, data in self.dev_data.iteritems():
+        for (name, data) in self.dev_data.items():
             partitions.append([data['major'], data['minor'], data['dev_size'],
-                              data['dev_name'].rpartition("/")[2]])
+                              data['dev_name']])
         return partitions
 
     def mock_is_directory(self, string):
@@ -226,7 +227,7 @@ class MockSystemDataSource(unittest.TestCase):
         dev_count += len(devices)
         self.pool_data[pool_name] = {'pool_name': pool_name,
                 'pool_size': str(pool_size), 'pool_used': str(pool_used),
-                'dev_count': str(dev_count), 'pool_free': str(pool_size),
+                'dev_count': str(dev_count), 'pool_free': str(pool_free),
                 'vol_count': '0'}
 
     def _addVol(self, vol_name, vol_size, stripes, pool_name, devices,
@@ -242,7 +243,7 @@ class MockSystemDataSource(unittest.TestCase):
             self.mount_data[devices[0]] = {'dev': devices[0], 'mp': mount,
                                            'root': "/"}
 
-        space_per_dev = vol_size / stripes
+        space_per_dev = vol_size // stripes
 
         size = vol_size
         for dev in devices:
diff --git a/tests/unittests/test_btrfs.py b/tests/unittests/test_btrfs.py
index 1132bd6..c1743af 100644
--- a/tests/unittests/test_btrfs.py
+++ b/tests/unittests/test_btrfs.py
@@ -57,11 +57,11 @@ class BtrfsFunctionCheck(MockSystemDataSource):
         self.run_data.append(" ".join(cmd))
         output = ""
         if cmd[:3] == ['btrfs', 'filesystem', 'show']:
-            for pool, p_data in self.pool_data.iteritems():
+            for (pool, p_data) in self.pool_data.items():
                 output += "Label: {0} uuid: some_random_uuid\n".format(pool)
                 count = 0
                 d_output = ""
-                for dev, d_data in sorted(self.dev_data.iteritems()):
+                for (dev, d_data) in sorted(self.dev_data.items()):
                     if 'pool_name' not in d_data or \
                        d_data['pool_name'] != pool:
                            continue
@@ -72,11 +72,11 @@ class BtrfsFunctionCheck(MockSystemDataSource):
                 output += d_output
         elif cmd[:3] == ['btrfs', 'subvolume', 'list']:
             mpoint = cmd[-1]
-            for pool, p_data in self.pool_data.iteritems():
+            for (pool, p_data) in self.pool_data.items():
                 if 'mount' not in p_data or p_data['mount'] != mpoint:
                     continue
                 count = 0
-                for vol, v_data in iter(sorted(self.vol_data.iteritems())):
+                for (vol, v_data) in iter(sorted(self.vol_data.items())):
                     if v_data['pool_name'] != pool:
                         continue
                     count += 1
@@ -235,7 +235,7 @@ class BtrfsFunctionCheck(MockSystemDataSource):
 
     def test_btrfs_resize(self):
 	# Btrfs resize not supported for now because it simply does not work
-	return
+        return
         # Generate some storage data
         self._addPool('default_pool', ['/dev/sda', '/dev/sdb'])
         self._addPool('my_pool', ['/dev/sdc2', '/dev/sdc3'])
diff --git a/tests/unittests/test_lvm.py b/tests/unittests/test_lvm.py
index 5096544..ae39b39 100644
--- a/tests/unittests/test_lvm.py
+++ b/tests/unittests/test_lvm.py
@@ -48,16 +48,16 @@ class LvmFunctionCheck(MockSystemDataSource):
         self.run_data.append(" ".join(cmd))
         output = ""
         if cmd[1] == 'pvs':
-            for dev, data in self.dev_data.iteritems():
+            for (dev, data) in self.dev_data.items():
                 if 'pool_name' in data:
                     output += "{0}|{1}|{2}|{3}\n".format(dev, data['pool_name'],
                             data['dev_free'], data['dev_used'])
         elif cmd[1] == 'vgs':
-            for pool, data in self.pool_data.iteritems():
+            for (pool, data) in self.pool_data.items():
                 output += "{0}|{1}|{2}|{3}|{4}\n".format(pool, data['dev_count'],
                         data['pool_size'], data['pool_free'], data['vol_count'])
         elif cmd[1] == 'lvs':
-            for vol, data in self.vol_data.iteritems():
+            for (vol, data) in self.vol_data.items():
                 output += "{0}|{1}|{2}|{3}|{4}|{5}|{6}|{7}\n".format(data['pool_name'],
                         data['vol_size'], data['stripes'], data['stripesize'],
                         data['type'], data['dev_name'].split("/")[-1],
diff --git a/tests/unittests/test_ssm.py b/tests/unittests/test_ssm.py
index e0a1d99..2de2ea5 100644
--- a/tests/unittests/test_ssm.py
+++ b/tests/unittests/test_ssm.py
@@ -33,7 +33,7 @@ from tests.unittests.common import *
 
 class SimpleStorageHandleSanityCheck(BaseStorageHandleInit):
     """
-    Simple sanity ckecks for StorageHandle class and some of its methods.
+    Simple sanity checks for StorageHandle class and some of its methods.
     """
 
     def test_constructor(self):
@@ -155,7 +155,7 @@ class StorageHandleSanityCheck(BaseStorageHandleInit):
             self.assert_(len(source.attrs) >  0)
             self.assert_(isinstance(source.types, list))
             self.assert_(len(source.types) >  0)
-            for item  in source._data.itervalues():
+            for item  in source._data.values():
                 self.assertTrue(item.options.force)
                 self.assertTrue(item.options.verbose)
                 self.assertTrue(item.options.yes)
@@ -196,7 +196,7 @@ class StorageHandleSanityCheck(BaseStorageHandleInit):
             self.assert_(len(source.attrs) > 0)
             self.assert_(isinstance(source.types, list))
             self.assert_(len(source.types) > 0)
-            for item  in source._data.itervalues():
+            for item  in source._data.values():
                 self.assertFalse(item.options.force)
                 self.assertFalse(item.options.verbose)
                 self.assertFalse(item.options.yes)
@@ -218,7 +218,7 @@ class StorageHandleSanityCheck(BaseStorageHandleInit):
             self.assert_("header" in obj)
             self.assert_("attrs" in obj)
             self.assert_("types" in obj)
-            for bknd in source._data.itervalues():
+            for bknd in source._data.values():
                 obj = dir(bknd)
                 self.assert_("__iter__" in obj)
                 self.assert_("__getitem__" in obj)
@@ -231,12 +231,12 @@ class StorageHandleSanityCheck(BaseStorageHandleInit):
                     self.assert_("default_pool_name" in obj)
 
     def test_volumes_specific_methods(self):
-        for bknd in self.vol._data.itervalues():
+        for bknd in self.vol._data.values():
             obj = dir(bknd)
             self.assert_("remove" in obj)
 
     def test_pool_specific_methods(self):
-        for bknd in self.pool._data.itervalues():
+        for bknd in self.pool._data.values():
             obj = dir(bknd)
             self.assert_("reduce" in obj)
             self.assert_("remove" in obj)
@@ -347,20 +347,42 @@ class SsmFunctionCheck(MockSystemDataSource):
         # Extend Volume
         self._checkCmd("ssm resize", ['--size +4m', '/dev/default_pool/vol003'],
             "vol resize /dev/default_pool/vol003 5120.0 False")
+        self._checkCmd("ssm resize", ['--size +50%', '/dev/default_pool/vol003'],
+            "vol resize /dev/default_pool/vol003 1536.0 False")
+        self._checkCmd("ssm resize", ['--size +50%USED', '/dev/default_pool/vol002'],
+            "vol resize /dev/default_pool/vol002 355926849.5 False")
+        self._checkCmd("ssm resize", ['--size +50%free', '/dev/default_pool/vol002'],
+            "vol resize /dev/default_pool/vol002 5980449420.5 False")
 
         # Shrink volume
         self._checkCmd("ssm resize", ['-s-100G', '/dev/default_pool/vol002'],
             "vol resize /dev/default_pool/vol002 132426625.0 False")
+        self._checkCmd("ssm resize", ['-s-50%', '/dev/default_pool/vol003'],
+            "vol resize /dev/default_pool/vol003 512.0 False")
+        self._checkCmd("ssm resize", ['-s-50%USED', '/dev/default_pool/vol002'],
+            "vol resize /dev/default_pool/vol002 118641600.5 False")
+        self._checkCmd("ssm resize", ['-s-1%free', '/dev/default_pool/vol002'],
+            "vol resize /dev/default_pool/vol002 122420921.09 False")
 
         # Set volume size
         self._checkCmd("ssm resize", ['-s 10M', '/dev/my_pool/vol001'],
             "vol resize /dev/my_pool/vol001 10240.0 False")
+        self._checkCmd("ssm resize", ['--size 80%', '/dev/default_pool/vol003'],
+            "vol resize /dev/default_pool/vol003 819.2 False")
+        self._checkCmd("ssm resize", ['--size 50%used', '/dev/default_pool/vol002'],
+            "vol resize /dev/default_pool/vol002 118642624.5 False")
+        self._checkCmd("ssm resize", ['--size 50%FREE', '/dev/default_pool/vol002'],
+            "vol resize /dev/default_pool/vol002 5743165195.5 False")
 
         # Set volume and add devices
         self._checkCmd("ssm resize -s 12T /dev/default_pool/vol003 /dev/sdc1 /dev/sde",
             [], "vol resize /dev/default_pool/vol003 12884901888.0 False")
         self.assertEqual(self.run_data[-2],
             "pool extend default_pool /dev/sdc1 /dev/sde")
+        self._checkCmd("ssm resize -s 1258291200% /dev/default_pool/vol003 /dev/sdc1 /dev/sde",
+            [], "vol resize /dev/default_pool/vol003 12884901888.0 False")
+        self.assertEqual(self.run_data[-2],
+            "pool extend default_pool /dev/sdc1 /dev/sde")
 
         # Set volume size
         self._checkCmd("ssm resize -s 10G /dev/default_pool/vol003 /dev/sdc1 /dev/sde",
@@ -373,6 +395,10 @@ class SsmFunctionCheck(MockSystemDataSource):
             [], "vol resize /dev/default_pool/vol003 12884902912.0 False")
         self.assertEqual(self.run_data[-2],
             "pool extend default_pool /dev/sdc1 /dev/sde")
+        self._checkCmd("ssm resize -s +1258291100% /dev/default_pool/vol003 /dev/sdc1 /dev/sde",
+            [], "vol resize /dev/default_pool/vol003 12884901888.0 False")
+        self.assertEqual(self.run_data[-2],
+            "pool extend default_pool /dev/sdc1 /dev/sde")
 
         # Shrink volume with devices provided
         self._checkCmd("ssm resize -s-10G /dev/default_pool/vol002 /dev/sdc1 /dev/sde",
@@ -381,10 +407,17 @@ class SsmFunctionCheck(MockSystemDataSource):
             "pool extend default_pool /dev/sdc1 /dev/sde")
         self.assertNotEqual(self.run_data[-2],
             "pool extend default_pool /dev/sdc1")
+        self._checkCmd("ssm resize -s-50% /dev/default_pool/vol002 /dev/sdc1 /dev/sde",
+            [], "vol resize /dev/default_pool/vol002 118642112.5 False")
+        self.assertNotEqual(self.run_data[-2],
+            "pool extend default_pool /dev/sdc1 /dev/sde")
+        self.assertNotEqual(self.run_data[-2],
+            "pool extend default_pool /dev/sdc1")
 
         # Test that we do not use devices which are already used in different
         # pool
         self.assertRaises(Exception, main.main, "ssm resize -s +1.5T /dev/my_pool/vol001 /dev/sdb /dev/sda")
+        self.assertRaises(Exception, main.main, "ssm resize -s +200%FREE /dev/my_pool/vol001 /dev/sdb /dev/sda")
 
         # If the device we are able to use can cover the size, then
         # it will be resized successfully
@@ -418,18 +451,18 @@ class SsmFunctionCheck(MockSystemDataSource):
         self._cmdEq("force verbose pool new {0} /dev/sda".format(main.DEFAULT_DEVICE_POOL), -3)
 
         self._checkCmd("ssm create", ['-s 2.6T', '/dev/sda'],
-            "pool create {0} 2791728742.40 /dev/sda".format(main.DEFAULT_DEVICE_POOL))
+            "pool create {0} 2791728742.4 /dev/sda".format(main.DEFAULT_DEVICE_POOL))
         self._cmdEq("pool new {0} /dev/sda".format(main.DEFAULT_DEVICE_POOL), -2)
 
         self._checkCmd("ssm create", ['-r 0', '-s 2.6T', '-I 16', '/dev/sda'],
-            "pool create {0} 2791728742.40 0 16 /dev/sda".format(main.DEFAULT_DEVICE_POOL))
+            "pool create {0} 2791728742.4 0 16 /dev/sda".format(main.DEFAULT_DEVICE_POOL))
         self._cmdEq("pool new {0} /dev/sda".format(main.DEFAULT_DEVICE_POOL), -2)
 
         # Number of stripes must not exceed number of devices
         self.assertRaises(problem.GeneralError, main.main, "ssm create -r 1 -s 2.6T -I 16 -i 4 /dev/sda")
 
         self._checkCmd("ssm create", ['-r 1', '-s 2.6T', '-I 16', '/dev/sda /dev/sdb'],
-            "pool create {0} 2791728742.40 1 16 /dev/sda /dev/sdb".format(main.DEFAULT_DEVICE_POOL))
+            "pool create {0} 2791728742.4 1 16 /dev/sda /dev/sdb".format(main.DEFAULT_DEVICE_POOL))
         self._cmdEq("pool new {0} /dev/sda /dev/sdb".format(main.DEFAULT_DEVICE_POOL), -2)
 
         # Create volume using single device from non existent my_pool
@@ -438,15 +471,15 @@ class SsmFunctionCheck(MockSystemDataSource):
         self._cmdEq("pool new my_pool /dev/sda", -2)
 
         self._checkCmd("ssm create", ['--pool my_pool', '-s 2.6T', '/dev/sda'],
-            "pool create my_pool 2791728742.40 /dev/sda")
+            "pool create my_pool 2791728742.4 /dev/sda")
         self._cmdEq("pool new my_pool /dev/sda", -2)
 
         self._checkCmd("ssm create", ['-r 10', '-p my_pool', '-s 2.6T', '-I 16',
-            '/dev/sda'], "pool create my_pool 2791728742.40 10 16 /dev/sda")
+            '/dev/sda'], "pool create my_pool 2791728742.4 10 16 /dev/sda")
         self._cmdEq("pool new my_pool /dev/sda", -2)
 
         self._checkCmd("ssm create", ['-r 0', '-p my_pool', '-s 2.6T', '-I 16',
-            '/dev/sda'], "pool create my_pool 2791728742.40 0 16 /dev/sda")
+            '/dev/sda'], "pool create my_pool 2791728742.4 0 16 /dev/sda")
         self._cmdEq("pool new my_pool /dev/sda", -2)
 
         # Create volume using multiple devices
@@ -462,28 +495,45 @@ class SsmFunctionCheck(MockSystemDataSource):
         self._addPool(main.DEFAULT_DEVICE_POOL, ['/dev/sdb', '/dev/sdd'])
         self._checkCmd("ssm create", ['-r 10', '-s 2.6T', '-I 16',
             '-n myvolume', '/dev/sda'],
-            "pool create {0} 2791728742.40 myvolume 10 16 /dev/sda". format(main.DEFAULT_DEVICE_POOL))
+            "pool create {0} 2791728742.4 myvolume 10 16 /dev/sda". format(main.DEFAULT_DEVICE_POOL))
         self._cmdEq("pool extend {0} /dev/sda".format(main.DEFAULT_DEVICE_POOL), -2)
 
+        self._checkCmd("ssm create", ['-s 20%', '-n myvolume'],
+            "pool create {0} 46915624.8 myvolume". format(main.DEFAULT_DEVICE_POOL))
+
         self._addPool("my_pool", ['/dev/sdc2', '/dev/sdc3'])
         self._checkCmd("ssm create", ['-r 1', '-p my_pool', '-s 2.6T', '-I 16',
             '-n myvolume', '/dev/sda'],
-            "pool create my_pool 2791728742.40 myvolume 1 16 /dev/sda")
+            "pool create my_pool 2791728742.4 myvolume 1 16 /dev/sda")
         self._cmdEq("pool extend my_pool /dev/sda", -2)
 
         # Create volume using multiple devices which one of the is in already
         # in the pool
         self._checkCmd("ssm create", ['-r 0', '-s 2.6T', '-I 16',
             '-i 2', '-n myvolume', '/dev/sda /dev/sdb'],
-            "pool create {0} 2791728742.40 myvolume 0 2 16 /dev/sda /dev/sdb". format(main.DEFAULT_DEVICE_POOL))
+            "pool create {0} 2791728742.4 myvolume 0 2 16 /dev/sda /dev/sdb". format(main.DEFAULT_DEVICE_POOL))
         self._cmdEq("pool extend {0} /dev/sda".format(main.DEFAULT_DEVICE_POOL), -2)
 
         self._addPool("my_pool", ['/dev/sdc2', '/dev/sdc3'])
         self._checkCmd("ssm create", ['-r 10', '-p my_pool', '-s 2.6T', '-I 16',
             '-i 2', '-n myvolume', '/dev/sdc2 /dev/sda'],
-            "pool create my_pool 2791728742.40 myvolume 10 2 16 /dev/sdc2 /dev/sda")
+            "pool create my_pool 2791728742.4 myvolume 10 2 16 /dev/sdc2 /dev/sda")
         self._cmdEq("pool extend my_pool /dev/sda", -2)
 
+        # Test volume creation by specifying percentage instead of a concrete
+        # size
+        self._checkCmd("ssm create -s 20% -n myvolume", [],
+            "pool create {0} 46915624.8 myvolume".format(main.DEFAULT_DEVICE_POOL))
+        self._checkCmd("ssm create -s 20%free -n myvolume", [],
+            "pool create {0} 46915624.8 myvolume".format(main.DEFAULT_DEVICE_POOL))
+        self._addVol('vol002', 1073741824, 1, main.DEFAULT_DEVICE_POOL, ['/dev/sdc'])
+        self._checkCmd("ssm create -s 20% -n myvolume", [],
+            "pool create {0} 583786536.8 myvolume".format(main.DEFAULT_DEVICE_POOL))
+        self._checkCmd("ssm create -s 20%free -n myvolume", [],
+            "pool create {0} 369038172.0 myvolume".format(main.DEFAULT_DEVICE_POOL))
+        self._checkCmd("ssm create -s 20%used -n myvolume", [],
+            "pool create {0} 214748364.8 myvolume".format(main.DEFAULT_DEVICE_POOL))
+
         # Test that we do not use devices which are already used in different
         # pool
         self.assertRaises(Exception, main.main, "ssm create -p new_pool /dev/sdc2 /dev/sdc3")
@@ -491,7 +541,7 @@ class SsmFunctionCheck(MockSystemDataSource):
         # If the device we are able to use can cover the size, then
         # it will be created
         self._checkCmd("ssm create", ['-s 100M', '-p new_pool', '/dev/sdc2 /dev/sdc3 /dev/sda'],
-            "pool create new_pool 102400.00 /dev/sda")
+            "pool create new_pool 102400.0 /dev/sda")
 
         #sys.stdout = out.stdout
 
@@ -624,57 +674,77 @@ class SsmFunctionCheck(MockSystemDataSource):
 
         # Create snapshot
         self._checkCmd("ssm snapshot", ['/dev/default_pool/vol004'],
-            "vol snapshot /dev/default_pool/vol004 41943040.0 False")
+            "vol snapshot /dev/default_pool/vol004 None")
         # Create snapshot verbose
         self._checkCmd("ssm -v snapshot", ['/dev/default_pool/vol004'],
-            "verbose vol snapshot /dev/default_pool/vol004 41943040.0 False")
+            "verbose vol snapshot /dev/default_pool/vol004 None")
         # Create snapshot force
         self._checkCmd("ssm -f snapshot", ['/dev/default_pool/vol004'],
-            "force vol snapshot /dev/default_pool/vol004 41943040.0 False")
+            "force vol snapshot /dev/default_pool/vol004 None")
         # Create snapshot force verbose
         self._checkCmd("ssm -f -v snapshot", ['/dev/default_pool/vol004'],
-            "force verbose vol snapshot /dev/default_pool/vol004 41943040.0 False")
+            "force verbose vol snapshot /dev/default_pool/vol004 None")
 
         # Create snapshot with size specified
         self._checkCmd("ssm snapshot --size 1G", ['/dev/default_pool/vol004'],
-            "vol snapshot /dev/default_pool/vol004 1048576.0 True")
+            "vol snapshot /dev/default_pool/vol004 1048576.0")
+        self._checkCmd("ssm snapshot --size 10%", ['/dev/default_pool/vol004'],
+            "vol snapshot /dev/default_pool/vol004 20971520.0")
+        self._checkCmd("ssm snapshot --size 10%used", ['/dev/default_pool/vol004'],
+            "vol snapshot /dev/default_pool/vol004 56428367.4")
+        self._checkCmd("ssm snapshot --size 10%free", ['/dev/default_pool/vol004'],
+            "vol snapshot /dev/default_pool/vol004 1115933196.6")
         # Create snapshot with destination specified
         self._checkCmd("ssm snapshot --dest /mnt/test", ['/dev/default_pool/vol004'],
-            "vol snapshot /dev/default_pool/vol004 /mnt/test 41943040.0 False")
+            "vol snapshot /dev/default_pool/vol004 /mnt/test None")
         # Create snapshot with the name specified
         self._checkCmd("ssm snapshot --name test", ['/dev/default_pool/vol004'],
-            "vol snapshot /dev/default_pool/vol004 test 41943040.0 False")
+            "vol snapshot /dev/default_pool/vol004 test None")
         # Create snapshot with both destination and size specified
         self._checkCmd("ssm snapshot",
             ['--size 1G', '--dest /mnt/test' ,'/dev/default_pool/vol004'],
-            "vol snapshot /dev/default_pool/vol004 /mnt/test 1048576.0 True")
+            "vol snapshot /dev/default_pool/vol004 /mnt/test 1048576.0")
+        self._checkCmd("ssm snapshot",
+            ['--size 10%', '--dest /mnt/test','/dev/default_pool/vol004'],
+            "vol snapshot /dev/default_pool/vol004 /mnt/test 20971520.0")
+        self._checkCmd("ssm snapshot --dest /mnt/test --size 10%used",
+            ['/dev/default_pool/vol004'],
+            "vol snapshot /dev/default_pool/vol004 /mnt/test 56428367.4")
+        self._checkCmd("ssm snapshot --dest /mnt/test --size 10%free",
+            ['/dev/default_pool/vol004'],
+            "vol snapshot /dev/default_pool/vol004 /mnt/test 1115933196.6")
         # Create snapshot with both name and size specified
         self._checkCmd("ssm snapshot",
             ['--size 1G', '--name test' ,'/dev/default_pool/vol004'],
-            "vol snapshot /dev/default_pool/vol004 test 1048576.0 True")
+            "vol snapshot /dev/default_pool/vol004 test 1048576.0")
+        self._checkCmd("ssm snapshot",
+            ['--size 10%', '--name test','/dev/default_pool/vol004'],
+            "vol snapshot /dev/default_pool/vol004 test 20971520.0")
 
         # Repeat the test with specifying mount point instead of volume
 
         # Create snapshot
         self._checkCmd("ssm snapshot", ['/mnt/test'],
-            "vol snapshot /dev/default_pool/vol004 41943040.0 False")
+            "vol snapshot /dev/default_pool/vol004 None")
         # Create snapshot with size specified
         self._checkCmd("ssm snapshot --size 1G", ['/mnt/test'],
-            "vol snapshot /dev/default_pool/vol004 1048576.0 True")
+            "vol snapshot /dev/default_pool/vol004 1048576.0")
+        self._checkCmd("ssm snapshot --size 10%", ['/mnt/test'],
+            "vol snapshot /dev/default_pool/vol004 20971520.0")
         # Create snapshot with destination specified
         self._checkCmd("ssm snapshot --dest /mnt/test", ['/mnt/test'],
-            "vol snapshot /dev/default_pool/vol004 /mnt/test 41943040.0 False")
+            "vol snapshot /dev/default_pool/vol004 /mnt/test None")
         # Create snapshot with the name specified
         self._checkCmd("ssm snapshot --name test", ['/mnt/test'],
-            "vol snapshot /dev/default_pool/vol004 test 41943040.0 False")
+            "vol snapshot /dev/default_pool/vol004 test None")
         # Create snapshot with both destination and size specified
         self._checkCmd("ssm snapshot",
             ['--size 1G', '--dest /mnt/test' ,'/mnt/test'],
-            "vol snapshot /dev/default_pool/vol004 /mnt/test 1048576.0 True")
+            "vol snapshot /dev/default_pool/vol004 /mnt/test 1048576.0")
         # Create snapshot with both name and size specified
         self._checkCmd("ssm snapshot",
             ['--size 1G', '--name test' ,'/mnt/test'],
-            "vol snapshot /dev/default_pool/vol004 test 1048576.0 True")
+            "vol snapshot /dev/default_pool/vol004 test 1048576.0")
 
     def test_mount(self):
         self._addDir("/mnt/test")
@@ -721,11 +791,11 @@ class MyInfo(object):
         return 'verbose' if self.options.verbose else ''
 
     def __iter__(self):
-        for item in sorted(self.data.iterkeys()):
+        for item in sorted(self.data):
             yield item
 
     def __getitem__(self, key):
-        if key in self.data.iterkeys():
+        if key in self.data:
             return self.data[key]
 
 
@@ -789,9 +859,9 @@ class VolumeInfo(MyInfo):
         misc.run([self.f, self.v, self.y, 'vol resize', lv, str(size),
                   str(resize_fs)])
 
-    def snapshot(self, volume, destination, name, size, user_set_size):
+    def snapshot(self, volume, destination, name, snap_size=None):
         misc.run([self.f, self.v, self.y, 'vol snapshot', volume, destination,
-                name, str(size), str(user_set_size)])
+                name, str(snap_size)])
 
 
 class DevInfo(MyInfo):
